<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++整理笔记]]></title>
    <url>%2F2017%2F05%2F25%2FC-%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这篇文档主要对C++学习做一个比较系统但很简单的总结，主要为Qt学习做准备。 标准C++精讲 参考：[零基础学Qt4编程]（https://wizardforcel.gitbooks.io/wudi-qt4/content/19.html）]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac利器学习]]></title>
    <url>%2F2017%2F05%2F20%2FMac%E5%88%A9%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这篇文档主要对Mac上一些好用的软件进行一个归档整理，同时也会适时完善一些教程。 &lt;!—more—&gt; 20170520 - Marp 简介：Marp是一款可以用Markdown来制作PPT的软件 适用：以文字为主，图片占比不多的情况 特点： 适用Markdown语法 跨平台，包括W，M，L 目前包含两套主题，外加自定义背景图片 支持emoji表情 支持latex公式 支持导出为PDF文件 下载：Created by Yuki Hattori ( @yhatt ) 教程：Here或是安装后自带的example.md]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netcdf4安装教程]]></title>
    <url>%2F2017%2F05%2F19%2FNetcdf4%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本指南的目的在于实现netcdf4在个人PC或是服务器上的安装，主要实现功能是netcdf4中的数据压缩（Compression）功能，若需要其他功能，请参阅官方指南：Getting and Building netCDF。 所需安装包实现Data Compression所必须的安装包只有四个 HDF5 1.8.9 or later (for netCDF-4 support) zlib 1.2.5 or later (for netCDF-4 compression) netcdfc (latest version) netcdf-fortran (latest version) 另：非必装：curl 7.18.0 or later (for DAP remote access client support) 安装步骤 注意： 编译器的选择，在 /.configure中需要进行相关配置，也可在其之前就进行配置。在本次安装过程中，所需的C编译器和fortran编译器分别为intel的icc和ifort。 如果不需要压缩功能，可以直接忽略1,2步骤 编译器设置123456789export CC=iccexport CXX=icpcexport CFLAGS=&apos;-O3 -xHost -ip -no-prec-div -static-intel&apos;export CXXFLAGS=&apos;-O3 -xHost -ip -no-prec-div -static-intel&apos;export F77=ifortexport FC=ifortexport FCLAGS=&apos;-O3 -xHost -ip -no-prec-div -static-intel&apos;export CPP=&apos;icc -E&apos;export CXXCPP=&apos;icpc -E&apos; zlib安装12345ZDIR=/home/gaoxiao/software/zlib #文件安装所在位置mkdir $&#123;ZDIR&#125;./configure --prefix=$&#123;ZDIR&#125;make checkmake install 安装hdf512345H5DIR=/home/gaoxiao/software/hdf5mkdir $&#123;H5DIR&#125;./configure --with-zlib=$&#123;ZDIR&#125; --prefix=$&#123;H5DIR&#125; -enable-fortran -enable-cxx make checkmake install 注意： 必须要有--with-zlib=${ZDIR}，否则会报错相关库文件找不到。 在个人PC机上安装时，可能会提示C++的注释方式不可用于IS90规范中，遇此错误，目前的解决方法是找到相关文件，将C++的注释方式//改为C的注释方式/* */，目前已知安装过程中有两个文件共两处需要修改。若是没有报错可以直接忽略此条注意事项。 HDF5相关配置选项 安装Netcdfc12345NCDIR=/home/gaoxiao/software/netcdfcmkdir $&#123;NCDIR&#125;CPPFLAGS=&quot;-I$&#123;H5DIR&#125;/include -I$&#123;ZDIR&#125;/include&quot; LDFLAGS=&quot;-L$&#123;H5DIR&#125;/lib -L$&#123;ZDIR&#125;/lib&quot; ./configure --prefix=$&#123;NCDIR&#125; --enable-netcdf-4 --enable-largefile --disable-dapmake checkmake install 注意： 目前服务器simulator2上安装的netcdf4，在配置时选择了--disable-netcdf4，如此安装不需要以上的2,3步骤，可以直接安装，导致的结果是无法使用netcdf4中的一些新特性如Compression等功能； 必须包含CPPFLAGS=-I${H5DIR}/include LDFLAGS=-L${H5DIR}/lib，否则报错提示相关文件找不到； Netcdfc相关配置选项（网页中部位置） Netcdf-fortran安装12345678NFDIR=/home/gaoxiao/software/netcdf_fortranmkdir $&#123;NFDIR&#125;export CPPFLAGS=&quot;-I$&#123;ZDIR&#125;/include -I$&#123;H5DIR&#125;/include -I$&#123;NCDIR&#125;/include&quot;export LDFLAGS=&quot;-L$&#123;ZDIR&#125;/lib -L$&#123;H5DIR&#125;/lib -L$&#123;NCDIR&#125;/lib&quot;export LD_LIBRARY_PATH=$&#123;NCDIR&#125;/lib:$&#123;LD_LIBRARY_PATH&#125;CPPFLAGS=-I$&#123;NCDIR&#125;/include LDFLAGS=-L$&#123;NCDIR&#125;/lib ./configure --prefix=$&#123;NFDIR&#125; --disable-fortran-type-check make checkmake install 查看安装结果首先，需要将相关路径加入到.bsharc文件中1234567891011export PATH=/home/gaox/App_gaox/netcdfc/bin:$&#123;PATH&#125;export PATH=/home/gaox/App_gaox/netcdfc/include:$&#123;PATH&#125;export PATH=/home/gaox/App_gaox/netcdfc/lib:$&#123;PATH&#125;export PATH=$&#123;PATH&#125;:/home/gaox/App_gaox/netcdf_fortran/binexport PATH=/home/gaox/App_gaox/hdf5/include:$&#123;PATH&#125;export PATH=/home/gaox/App_gaox/hdf5/lib:$&#123;PATH&#125;export PATH=/home/gaox/App_gaox/hdf5/bin:$&#123;PATH&#125;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/App_gaox/netcdfc/libexport LIBRARY_PATH=/home/gaox/App_gaox/netcdfc/lib/:$LIBRARY_PATH 然后，可以通过nc-config --all查看所安装的netcdf的状态注意：不同配置选项最终结果可能不一样。 ReferencePart A：文档查阅1、Netcdf Official Site2、Netcdf Download Site3、Netcdf Documentation4、2011 Unidata NetCDF Workshop5、2012 Unidata NetCDF Workshop6、NetCDF Fortran 90 Interface Guide7、WELCOME to the HDF5 Home PagePart B：安装参考1、Getting and Building netCDF2、在CentOS上安裝netCDF4流程3、Linux下用Intel编译器编译安装NetCDF-Fortan库(4.2以后版本)4、netcdf安装 、zlib 、szip、hdf5、mpich2、curl系列软件安装 原文链接：简书]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>netcdf4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用地球物理软件安装]]></title>
    <url>%2F2017%2F05%2F17%2F%E5%B8%B8%E7%94%A8%E5%9C%B0%E7%90%83%E7%89%A9%E7%90%86%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[这篇文档主要用于记录一些常用的地球物理软件安装教程。 2017 - 05 - 16 Seismic Unix Installation 源码下载：CWP Homepage 当前最新版下载Here 解压到合适安装位置 123456# -C 指定特定的文件夹，示例是我电脑上的路径，实际安装需要你们自己设定路径，这与之后的路径设置相关，所以要小心，嫌麻烦可以采用通用设置tar -xvf cwp_su_all_44R5.tgz -C /home/gaox/App_gaox/su# 或者通用设置mkdir ~/sutar -xvf cwp_su_all_44R5.tgz -C ~/su ​ 安装依赖包 1234567sudo apt-get install build-essentialsudo apt-get install libx11-devsudo apt-get install libxt-devsudo apt-get install freeglut3-dev sudo apt-get install libxmu-devsudo apt-get install libxi-devsudo apt-get install gfortran 配置环境 打开配置文件.bashrc 1gedit ~/.bashrc 在配置文件中写入 12345678# Seismic Unix 44R1# 自定义版export CWPROOT=/home/gaox/App_gaox/suexport PATH=$PATH:/home/gaox/App_gaox/su/bin# 或者通用版（需要修改username）export CWPROOT=/home/usrname/suexport PATH=$PATH:/home/usrname/su/bin 注意： 以上二选一 username是自己的用户名 不要以root权限安装，否则相同会不稳定 保存之后需要运行以下语句： 1source ~/.bashrc 编译安装 进入解压缩之后的文件夹，一般为src 1234567891011# 进入源码srccd ~/su/src# 复制相应的Makefile文件，需要注意的是文件后缀是相应的系统架构，根据相应的系统架构复制即可cp configs/Makefile.config_Linux_x86_64 $CWPROOT/src/Makefile.config# 安装指令make installmake xtinstallmake finstallmake mglinstall 检查是否安装成功 1suplane | suxwigb &amp; 若出现以下图说明安装成功了 ​]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>su</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux利器学习]]></title>
    <url>%2F2017%2F05%2F09%2FLinux%E5%88%A9%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这篇文章主要对Linux中遇到的比较好的工具进行归纳总结，以备不时之需。 2017 - 05 - 09： Screen 简介：Screen是一个可以在多个进程之间多路复用一个物理终端的全屏窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。 安装：对于debian/ubuntu系统，可以直接执行命令 1sudo apt-get install screen 简单使用教程 创建会话：screen -S nm 暂时离开：Ctrl + a d 回复会话：screen -r nm或screen -r pid 查看会话：screen -ls 关闭会话：exit，出现screen is terminating表示成功退出screen会话 高级功能 首先演示者先在服务器上执行 screen -S test 创建一个screen会话，观众可以链接到远程服务器上执行screen -x test 观众屏幕上就会出现和演示者同步。[多屏模式] 常用快捷键 Ctrl+a c ：在当前screen会话中创建窗口 Ctrl+a w ：窗口列表 Ctrl+a n ：下一个窗口 Ctrl+a p ：上一个窗口 Ctrl+a 0-9 ：在第0个窗口和第9个窗口之间切换]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F04%2F26%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[这篇文档主要对正则表达式进行一个较为初步的学习。 &lt;!—more—&gt; 什么是正则表达式简言之，正则表达式——记录文本规则的代码。 入门 查找hi——\bhi\b 忽略大小写可以匹配：hi，Hi，hI，HI，同时也会找出包含这两个字符的单词 精确查找\bhi\b，\b表示元字符，代表单词的开头结尾，也即是单词的分界。需要注意的是：\b并不匹配空格，换行或是标点符号，它只是匹配一个位置：它的前一个字符和后一个字符不全是(一个是，一个不是或不存在)\w 。 查找hi，Lucy——\bhi\b.*\bLucy\b .：元字符，匹配换行符之外的任意字符 *：元字符，匹配数量，表示前边的内容可以连续重复使用任意次以使整个表达式得到匹配 .*：任意数量的不包含换行的字符 综上：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词 换行符：\n，ASCII编码是10 0\d\d-\d\d\d\d\d\d\d\d \d：元字符，匹配一位数字 -：不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它) 综上：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形) 可以简写为：0\d{2}-\d{8}——这里 \d 后面的{2}({8})的意思是前面\d 必须连续重复匹配2次(8次)。 元字符 \s：匹配任意的空白符，包括空格，制表符（Tab)，换行符，中文全角空格 \ba\w*\b： 先是某个单词开始处(\b)，然后是字母 a，然后是任意数量的字母或数字 (\w*) ，最后是单词结束处(\b) \d+：匹配1个或更多连续的数字，+类似于*，但是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次 \b\w{6}\b：匹配刚好6个字符的单词 \d{5,12}：如果不使用 ^和$ 的话，\d{5,12}只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。 ^\d{5,12}$ ^：匹配你要用来查找的字符串的开头 $： 匹配结尾 这里的{5,12} 和前面介绍过的{2}是类似的，只不过 {2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配 因为使用了^ 和 $ ，所以输入的整个字符串都要用来和 d{5,12} 来匹配，也就是说整个输入必须是5到12个数字 如果选中了处理多行的选项， ^和$的意义就变成了匹配行的开始处和结束处。 字符转义——\如果你想查找元字符本身的话，比如你查找., 或者 * ,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用\.和 \* 。当然，要查找\本身，你也得用\\。 regtest\.py匹配 regtest.py C:\\Windows 匹配 C:\Windows 重复——限定符 限定符：指定数量的代码 Windows\d+：其后跟1个或多个数字 \^\w+：匹配 一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) 字符类——[ ] [aeiou]：匹配aeiou中任何一个英文元音字母 [.?!]：匹配标点符号 [0-9]：等价于\d [a-z0-9A-Z]：等价于\w（不考虑中文） \(?0\d{2}[) -]?\d{8}：首先是一个转义字符 \( ,它能出现0次或1次? ,然后是一个0，后面跟着2个数字 \d{2}，然后是)或-或空格中的一个，它出现1次或不出现?，最后是8个数字 \d{8}。（存在缺陷） ？？分枝条件——| 0\d{2}-\d{8}|0\d{3}-\d{7} 一种是三位区号，8位本地号(如 010-12345678 ) 一种是四位区号，7位本地号( 0376-2233445 ) \(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}：这个表达式匹配 3 位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。 \d{5}-\d{4}|\d{5}：美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。 \d{5}|\d{5}-\d{4}：那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 ？？？？ 反义 \S+ ：匹配 不包含空白符的字符串 &lt;a[^&gt;]+&gt;：匹配用尖括号括起来的以a开头的字符串 其中间可以有空白等任意字符，与&lt;a.+&gt;的区别是当一行中有多个&gt;时它只会匹配到第一个&gt;位置处。 注意：最后两个没有\ 分组——( ) (\d{1,3}\.){3}\d{1,3}：简单的 IP 地址匹配表达式 请按下列顺序分析它： \d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字 (\d{1,3}) ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) 2[0-4]\d：匹配200～249 25[0-5]：匹配250～255 [01]?\d\d?：匹配000～199 分组复用——后向引用（捕获） 使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。 默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 后向引用用于重复搜索前面某个分组匹配的文本。例如， \1 代表分组1匹配的文本。 \b(\w+)\b\s+\1\b：可以用来匹配重复的单词 这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b) ，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+) ，最后是分组1中捕获的内容（ 也就是前面匹配的那个单词）(\1) 自定义子表达式的组名。要指定一个子表达式的组名，请使用这样的语法： (?&lt;Word&gt;\w+)(或者把尖括号换成&#39;也行： (?&#39;Word&#39;\w+)) ,这样就把 \w+ 的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用 \k&lt;Word&gt; ,所以上一个例子也可以写成这样：\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b 常用分组语法 第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容 不会像前两种那样被捕获到某个组里面，也不会拥有组号。？？？？ 零宽断言——前后位置匹配所谓零宽断言即进行位置匹配，以找到该位置前面或者后面所需要的匹配内容。类似于\b,\^,$用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。 (?=exp) 零宽度正预测先行断言：它断言自身出现的位置的后面能匹配表达式exp。 \b\w+(?=ing\b)：匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I&#39;m singing while you&#39;re dancing. 时，它会匹配sing 和 danc。 (?&lt;=exp) 零宽度正回顾后发断言：它断言自身出现的位置的前面能匹配表达式 exp 。 (?&lt;=\bre)\w+\b：匹配以 re 开头的单词的后半部分(除了re以外的部分)，例如在查找 reading a book 时，它匹配 ading 。 (?&lt;=\s)\d+(?=\s)：匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 负向零宽断言——当前位置匹配 \b\w*q[^u]\w*\b：匹配包含后面不是字母 u 的字母 q 的单词 特殊情况：如果q出现在单词的结尾的话，这个表达式就会出错。这是因为 [^u] 总要匹配一个字符，所以如果 q是单词的最后一个字符的话，后面的[^u] 将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的 \w*\b将会匹配下一个单词，于是b\w*q[^u]\w*\b就能匹配整个Iraq fighting。 \b\w*q(?!u)\w*\b 零宽度负预测先行断言：断言此位置的后面不能匹配表达式 exp \d{3}(?!\d)：匹配三位数字，而且这三位数字的后面不能是数字 \b((?!abc)\w)+\b：匹配不包含连续字符串abc的单词 (?&lt;!exp) 零宽度负回顾后发断言：断言此位置的前面不能匹配表达式exp (?&lt;![a-z])\d{7}： 匹配前面不是小写字母的七位数字 (?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)：匹配不包含属性的简单HTML标签内里的内容 (?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是 \b) 然后是.*(任意的字符串) 最后是一个后缀(?=&lt;\/\1&gt;) 后缀里的\/ ，它用到了前面提过的字符转义 \1 则是一个反向引用（分组），引用的正是捕获的第一组，前面的 (\w+)匹配的内容 整个表达式匹配的是和之间的内容(再次提醒，不包括前缀和后缀本身)。 注释——(?#comment) 2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199) 要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略 启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。 例如： 1234567(?&lt;= # 断言要匹配的文本的前缀&lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)) # 前缀结束.* # 匹配任意文本(?= # 断言要匹配的文本的后缀&lt;\/\1&gt; # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签) # 后缀结束 贪婪与懒惰 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（ 在使整个表达式能得到匹配的前提下） 匹配尽可能多的字符； 懒惰匹配：匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号? 例：a.*b，表达式aabab。前者：aabab；后者：aab。 处理选项 Python 中常用的正则表达式选项 平衡组/递归匹配 有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\(.+\) 则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) ) ，那我们的匹配结果里两者的个数也不会相等。 平衡组语法构造： (?&#39;group&#39;) ：把捕获的内容命名为group,并压入堆栈(Stack) (?&#39;-group&#39;)： 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则 本分组的匹配失败 (?(group)yes|no) ：如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达 式，否则继续匹配no部分 (?!)：零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败 例子： 1234567891011121314&lt; #最外层的左括号 [^&lt;&gt;]* #最外层的左括号后面的不是括号的内容 ( ( (?&apos;Open&apos;&lt;) #碰到了左括号，在黑板上写一个&quot;Open&quot; [^&lt;&gt;]* #匹配左括号后面的不是括号的内容 )+ ( (?&apos;-Open&apos;&gt;) #碰到了右括号，擦掉一个&quot;Open&quot; [^&lt;&gt;]* #匹配右括号后面不是括号的内容 )+ )* (?(Open)(?!)) #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&quot;Open&quot;；如果还有，则匹配失败&gt; #最外层的右括号 平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的 1&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?&apos;Open&apos;&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?&apos;-Open&apos;&lt;/div&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))&lt;/div&gt; 还有一些没有提到的语法 一些网上的总结图 参考： 正则表达式30分钟入门教程 正则表达式学习笔记 正则表达式30分钟入门教程-deerchao 微软的正则表达式教程 Python: Regular expression operations 专业的正则表达式教学网站(英文) Summary Pictures]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell-script实战]]></title>
    <url>%2F2017%2F04%2F25%2Fshell-script%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[这篇文档主要记录记录日常遇到的一些自编的shell脚本，慢慢积累。 批量对文件进行操作解压缩12345678910111213141516171819########################################################################## File Name: decompress-sz.sh# Author: gaox# Mail: gaox1993@mail.ustc.edu.cn# Created Time: Tue 25 Apr 2017 15:56:45 CST# Version: 1.0##########################################################################!/bin/bash# This script is used to decomress sz dataPSZ=/home/gaox/App_gaox/sz-latest/sz.configPDE=/home/gaox/App_gaox/sz-latest/binPDA=.for i in `ls $PDA/*.sz`do $PDE/testfloat_decompress $PSZ $i 1 50 50 300done]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30分钟shell入门]]></title>
    <url>%2F2017%2F04%2F24%2F30%E5%88%86%E9%92%9Fshell%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这篇文档主要学习一下shell的基本语法与操作。 Shell简介 C语言编写实现 既是命令语言，也是程序设计语言。前者：交互的解释和执行用户输入的命令。后者：定义了各种变量和参数，并提供了高级控制结构。 shell的两种执行方式 交互式：解释执行用户输入的命令，用户输入一条，shell解释一条 批处理（batch）：用户事先写一个shell脚本，让用户一次执行所有命令 几种常见的Shell一般来说这里的shell指的是shell脚本解释器（内核）。 bash：Linux默认的标准shell，共40个内部命令，完全兼容sh sh：Unix默认的标准shell ash：Linux系统中占用资源最少的shel，不过只包含24个命令，使用不便 csh：Linux中比较大的内核，共52个命令，其实质是/bin/tcsh ksh：共42条命令，与商业发行版的ksh几乎完全兼容 shell脚本语言与编译型语言的差异程序设计语言大致分为两大类： 编译型语言：主要是一些传统的语言，如C，C++，Fortrn等 需要编译：将源代码转换为目标代码 运行时直接读取目标代码（机器语言），因而执行效率高 由于大多都是进行底层操作，因而就比较难进行一些文件类的操作，如文件复制，重命名等 解释型语言：也称为脚本语言，常见的如shell，Perl以及Python语言 运行时，解释器直接读取源码，然后将其转换为目标代码，最后运行 优点：易于处理文件类的操作 缺点：运行效率不及编译型的语言 第一个Shell脚本12#!/bin/bashecho &quot;Hello world!&quot; #!是预定标记，告诉系统使用什么解释器来执行命令 运行方法： 作为可执行程序：chmod +x test.sh 作为解释器参数：/bin/sh tesh.sh，以这种方式运行，不需要在第一行指定解释器信息 另一个例子：使用read从stdin获取输入并赋值给PERSON变量，最后在stdou输出 123456789#!/bin/bash# Author : mozhiyan# Copyright (c) http://OutOfMemory.CN/cpp/linux/# Script follows here:echo &quot;What is your name?&quot;read PERSONecho &quot;Hello, $PERSON&quot; Shell变量定义变量1variablename=&quot;value&quot; 变量名与等号之间不能有空格 变量名规则：字母，数字及下划线 首个字符必须为字母（a-z，A-Z）。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 使用变量1234your_name=&quot;mozhiyan&quot;echo $your_name# ORecho $&#123;your_name&#125; #推荐 使用定义过的变量：变量名前加美元符号($) 变量名外的花括号可选，避免歧义。推荐加上 重新定义变量12345myUrl=&quot;http://OutOfMemory.CN/cpp/linux/&quot;echo $&#123;myUrl&#125;myUrl=&quot;http://OutOfMemory.CN/cpp/shell/&quot;echo $&#123;myUrl&#125; 需要注意的是重新定义的时候不能有$ 只读变量12345#!/bin/bashmyUrl=&quot;http://OutOfMemory.CN/cpp/shell/&quot;readonly myUrlmyUrl=&quot;http://OutOfMemory.CN/cpp/danpianji/&quot; 执行上述脚本，报错 原因：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 删除变量1unset variable_name 使用unset命令可以删除变量，变量删除后不可再次使用 unset不能删除只读变量 12345#!/bin/shmyUrl=&quot;http://OutOfMemory.CN/cpp/u/xitong/&quot;unset myUrlecho $myUrl # 没有任何输出 变量类型 局部变量：在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 特殊变量 命令行参数：运行脚本时，传递给脚本的参数称为命令行参数，第n个参数就是$n \$*和\$@的区别： 不加双引号（” “）它们两个一样，都是参数分开输出； 加双引号时，”\$*“表示一个字符串”\$1 \$2 … \$n”，”\$@”表示n个字符串为”\$1” “\$2” … “\$n”。 退出状态：\$? 可以获取上一个命令的退出状态，即上一个命令执行后的返回结果，一般成功返回 0， 失败返回 1 Shell替换转义字符1234#!/bin/basha=10echo -e &quot;Value of a is $a \n&quot; 使用-e表示对转义字符进行替换，不加的话会原样输出 可以在echo中使用的转义字符（类似于C） ​ -E：echo命令禁止转义，默认不转义 -n：禁止插入换行符 命令替换命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。 1`command` #注意是反引号，不是单引号 例子： 12345678910#!/bin/bashDATE=`date` #运行data命令，同时将结果保存在DATE中echo &quot;Date is $DATE&quot;USERS=`who | wc -l`echo &quot;Logged in user are $USERS&quot;UP=`date ; uptime`echo &quot;Uptime is $UP&quot; 变量替换根据变量的状态（是否为空，是否定义等）来改变他的值。 word指的是字符串或是其他变量 例子： 123456789101112131415161718192021222324252627282930#!/bin/bashecho $&#123;var:-&quot;Variable is not set&quot;&#125;echo &quot;1 - Value of var is $&#123;var&#125;&quot;echo $&#123;var:=&quot;Variable is not set&quot;&#125;echo &quot;2 - Value of var is $&#123;var&#125;&quot;unset varecho $&#123;var:+&quot;This is default value&quot;&#125;echo &quot;3 - Value of var is $var&quot;var=&quot;Prefix&quot;echo $&#123;var:+&quot;This is default value&quot;&#125;echo &quot;4 - Value of var is $var&quot;echo $&#123;var:?&quot;Print this message&quot;&#125;echo &quot;5 - Value of var is $&#123;var&#125;&quot;# ResultVariable is not set1 - Value of var isVariable is not set2 - Value of var is Variable is not set3 - Value of var isThis is default value4 - Value of var is PrefixPrefix5 - Value of var is Prefix Shell注释 使用#来进行注释 没有块注释，只有行注释 可以通过加花括号+定义函数的方式来实现块注释（不进行调用函数调用） Shell运算符算术运算符原生的bash不支持简单的数学运算，但是可以通过其他命令来实现，例如awk和expr 123456#!/bin/bashval=`expr 2 + 2`echo &quot;Total value : $val&quot;# ResultTotal value : 4 expr 是一款表达式计算工具，使用它能完成表达式的求值操作 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。见命令替换 例子： 1234567891011121314151617181920212223242526272829#!/bin/sha=10b=20val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;val=`expr $a \* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;if [ $a == $b ]then echo &quot;a is equal to b&quot;fiif [ $a != $b ]then echo &quot;a is not equal to b&quot;fi# Reuslta + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a is not equal to b 乘号(*)前边必须加反斜杠(\)才能实现乘法运算； if...then...fi是条件语句，后续将会讲解。 条件表达式要放在方括号之间，并且要有空格，例如 [\$a==\$b] 是错误的，必须写成 [ \$a == \$b ] 常见的算术运算符： 关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字 条件表达式：方括号 + 空格 布尔运算符 字符串运算符 =在算术运算符中是是赋值，但在字符串运算符中是比较字符串是否相等 z=zero , n=not zero 文件测试运算符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/bin/shfile=&quot;/var/www/tutorialspoint/unix/test.sh&quot;if [ -r $file ]then echo &quot;File has read access&quot;else echo &quot;File does not have read access&quot;fiif [ -w $file ]then echo &quot;File has write permission&quot;else echo &quot;File does not have write permission&quot;fiif [ -x $file ]then echo &quot;File has execute permission&quot;else echo &quot;File does not have execute permission&quot;fiif [ -f $file ]then echo &quot;File is an ordinary file&quot;else echo &quot;This is sepcial file&quot;fiif [ -d $file ]then echo &quot;File is a directory&quot;else echo &quot;This is not a directory&quot;fiif [ -s $file ]then echo &quot;File size is zero&quot;else echo &quot;File size is not zero&quot;fiif [ -e $file ]then echo &quot;File exists&quot;else echo &quot;File does not exist&quot;fi# Result 假定：大小为100字节，具有 rwx 权限File has read accessFile has write permissionFile has execute permissionFile is an ordinary fileThis is not a directoryFile size is zeroFile exists 常见的文件测试运算符 Shell字符串字符串可以用单引号，也可以用双引号，也可以不用引号。 单引号1str=&apos;this is a string&apos; 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。 双引号12your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot; 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串1234your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting $greeting_1 获取字符串长度12string=&quot;abcd&quot;echo $&#123;#string&#125; # 在变量名前加#，输出 4 提取子字符串12string=&quot;alibaba is a great company&quot;echo $&#123;string:1:4&#125; # 第一个为0, 实际提取的是第2：5个字母，输出liba 查找子字符12string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is` # 查找的字符串为is，但是最终返回的是字母i第一次出现的位置，与is没有关系 Shell数组 只支持一维数组，不支持多维数组，数组大小不限 下标从0开始，获取相应的元素要使用下标，下标可以使算术表达式 定义数组1234567array_name=(value0 value1 value2 value3)# ORarray_name[0]=value0array_name[1]=value1array_name[2]=value2 小括号表示数组 元素之间用空格分隔 也可以类似于C 中的单独定义各元素 可以使用不连续的小标，而且下标范围没有限制 读取数组1valuen=$&#123;array_name[index]&#125; 使用@ 或 * 可以获取数组中的所有元素，依次输出结果 获取数组长度123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125; # 在变量前加`#`# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; Shell echo echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。命令格式： 1echo $arg 显示转义字符 12echo &quot;\&quot;It is a test\&quot;&quot;# &quot;It is a test&quot; 对于前面提到的特殊转义字符，可以使用选项来设置是否转义输出，但是对于普通的转义字符不能设置是否输出，如同本例 双引号在这可以省略 显示变量 123456name=&quot;OK&quot;echo &quot;$name It is a test&quot;# 相连情况mouth=8echo &quot;$&#123;mouth&#125;-1-2009&quot; # 不加大括号将会导致无法区分变量 如果变量与其它字符相连的话，需要使用大括号（{ }） 显示换行 12echo &quot;OK!\n&quot;echo &quot;It is a test&quot; 显示不换行 12echo &quot;OK!\c&quot;echo &quot;It is a test&quot; 显示结果重定向到文件 1echo &quot;It is a test&quot; &gt; myfile 原样输出字符串 1echo &apos;$name\&quot;&apos; 不进行转义，单引号 显示执行的命令 1echo `date` # ``之中的是一个命令 Shell Printf 用于格式化输出，是echo的增强版 C语言printf()函数的一个有限变形，语法也略有不同 printf 命令不用加括号 format-string 可以没有引号，但最好加上，单引号双引号均可。 参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换。 arguments 使用空格分隔，不用逗号。 用法： 1printf format-string [arguments...] 例子： 123456789101112131415161718192021222324252627# format-string为双引号$ printf &quot;%d %s\n&quot; 1 &quot;abc&quot;1 abc# 单引号与双引号效果一样 $ printf &apos;%d %s\n&apos; 1 &quot;abc&quot; 1 abc# 没有引号也可以输出$ printf %s abcdefabcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用$ printf %s abc defabcdef$ printf &quot;%s\n&quot; abc defabcdef$ printf &quot;%s %s %s\n&quot; a b c d e f g h i ja b cd e fg h ij# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替$ printf &quot;%s and %d \n&quot; and 0# 如果以 %d 的格式来显示字符串，那么会有警告，提示无效的数字，此时默认置为 0$ printf &quot;The first program always prints&apos;%s,%d\n&apos;&quot; Hello Shell-bash: printf: Shell: invalid numberThe first program always prints &apos;Hello,0&apos; Shell if-elseShell 有三种 if … else 语句： if … fi 语句； if … else … fi 语句； if … elif … else … fi 语句。 if … fi 语句1234if [ expression ]then Statement(s) to be executed if expression is truefi expression 和方括号[ ]之间必须有空格，否则会有语法错误。 if … else … fi 语句123456if [ expression ]then Statement(s) to be executed if expression is trueelse Statement(s) to be executed if expression is not truefi if … elif … fi 语句123456789101112if [ expression 1 ]then Statement(s) to be executed if expression 1 is trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is trueelse Statement(s) to be executed if no expression is truefi if … else 语句也可以写成一行，以命令的方式来运行，像这样： 12if test $[2*3] -eq $[1+5]; then echo &apos;The two numbers are equal!&apos;; fi;# test 命令用于检查某个条件是否成立，与方括号([ ])类似。 Shell testShell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。等同于[ ] Shell case-esac1234567891011121314151617case 值 in模式1) command1 command2 command3 ;;模式2） command1 command2 command3 ;;*) command1 command2 command3 ;;esac case 语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令。 取值后面必须为关键字 in，每一模式必须以右括号，取值可以为变量或常数。 匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。 如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 例1： 123456789101112131415echo &apos;Input a number between 1 to 4&apos;echo &apos;Your number is:\c&apos;read aNumcase $aNum in 1) echo &apos;You select 1&apos; ;; 2) echo &apos;You select 2&apos; ;; 3) echo &apos;You select 3&apos; ;; 4) echo &apos;You select 4&apos; ;; *) echo &apos;You do not select a number between 1 to 4&apos; ;;esac 例2： 1234567891011121314#!/bin/bashoption=&quot;$&#123;1&#125;&quot; # 参见特殊变量 $1 等于 第2个变量（从0开始计算变量）case $&#123;option&#125; in -f) FILE=&quot;$&#123;2&#125;&quot; echo &quot;File name is $FILE&quot; ;; -d) DIR=&quot;$&#123;2&#125;&quot; echo &quot;Dir name is $DIR&quot; ;; *) echo &quot;`basename $&#123;0&#125;`:usage: [-f file] | [-d directory]&quot; exit 1 # Command to come out of the program with status 1 ;;esac 结果： 123456$./test.shtest.sh: usage: [ -f filename ] | [ -d directory ]$ ./test.sh -f index.htmFile name is index.htm$ ./test.sh -d unixDir name is unix Shell for1234567for 变量 in 列表do command1 command2 ... commandNdone 列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。 in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。 Shell while1234while commanddo Statement(s) to be executed if command is truedone 命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。 用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件（使用test或是中括号[ ]。 例子： 123456echo &apos;type &lt;CTRL-D&gt; to terminate&apos;echo -n &apos;enter your most liked film: &apos;while read FILMdo echo &quot;Yeah! great film the $FILM&quot;done Shell until1234until command # 为真时停止do Statement(s) to be executed until command is truedone until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。 一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。 例子： 1234567#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done Shell break和continuebreak12345678910111213#!/bin/bashwhile : # 死循环do echo -n &quot;Input a number between 1 to 5: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;Your number is $aNum!&quot; ;; *) echo &quot;You do not select a number between 1 to 5, game is over!&quot; break ;; esacdone break命令允许跳出本层循环 在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环， 1break n # 表示跳出第n层循环 continue1234567891011121314#!/bin/bashwhile :do echo -n &quot;Input a number between 1 to 5: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;Your number is $aNum!&quot; ;; *) echo &quot;You do not select a number between 1 to 5!&quot; continue echo &quot;Game is over!&quot; ;; esacdone continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 同样，continue 后面也可以跟一个数字，表示跳出第几层循环。 Shell函数12345678910function_name () &#123; list of commands [ return value ]&#125;# ORfunction function_name () &#123; list of commands [ return value ]&#125; Shell 函数必须先定义后使用。 函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。 Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。 如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。 调用函数只需要给出函数名，不需要加括号。 例子： 1234567891011121314#!/bin/bashfunWithReturn()&#123; echo &quot;The function is to get the sum of two numbers...&quot; echo -n &quot;Input first number: &quot; read aNum echo -n &quot;Input another number: &quot; read anotherNum echo &quot;The two numbers are $aNum and $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;funWithReturn# Capture value returnd by last commandret=$? # $? 上个命令退出状态或是函数返回值echo &quot;The sum of two numbers is $ret !&quot; 像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 .f 选项，如下所示： 1$unset -f function_name Shell函数参数1234567891011121314151617181920#!/bin/bashfunWithParam()&#123; echo &quot;The value of the first parameter is $1 !&quot; echo &quot;The value of the second parameter is $2 !&quot; echo &quot;The value of the tenth parameter is $10 !&quot; echo &quot;The value of the tenth parameter is $&#123;10&#125; !&quot; echo &quot;The value of the eleventh parameter is $&#123;11&#125; !&quot; echo &quot;The amount of the parameters is $# !&quot; # 参数个数 echo &quot;The string of the parameters is $* !&quot; # 传递给函数的所有参数&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73# ResultThe value of the first parameter is 1 !The value of the second parameter is 2 !The value of the tenth parameter is 10 !The value of the tenth parameter is 34 !The value of the eleventh parameter is 73 !The amount of the parameters is 12 !The string of the parameters is 1 2 3 4 5 6 7 8 9 34 73 !&quot; 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 \$n 的形式来获取参数的值，例如，\$1表示第一个参数，\$2表示第二个参数… \$10 不能获取第十个参数，获取第十个参数需要\${10}。当n&gt;=10时，需要使用\${n}来获取参数。 特殊变量： Shell输入输出重定向输出重定向123$ command &gt; file# OR$ conmand &gt;&gt; file # 追加内容到文件末尾 命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。 输入重定向1$ command &lt; file 本来需要从键盘获取输入的命令会转移到文件读取内容 深入理解一些内容一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。 12345678910111213# 如果希望 stderr 重定向到 file，可以这样写：$command 2 &gt; file# 如果希望 stderr 追加到 file 文件末尾，可以这样写：$command 2 &gt;&gt; file# 如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：$command &gt; file 2&gt;&amp;1# OR$command &gt;&gt; file 2&gt;&amp;1# 如果希望对 stdin 和 stdout 都重定向，可以这样写：$command &lt; file1 &gt;file2 # command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2 Here document123command &lt;&lt; delimiter documentdelimiter Here Document 是 Shell 中的一种特殊的重定向方式，可以译为”嵌入文档“ 它的作用是将两个 delimiter （EOF)之间的内容(document) 作为输入传递给 command。 注意： 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。 例1： 1234567$wc -l &lt;&lt; EOF This is a simple lookup program for good (and bad) restaurants in Cape Town.EOF3$ 例2： 123456789#!/bin/shfilename=test.txtvi $filename &lt;&lt;EndOfCommandsiThis file was created automatically froma shell script^[ZZEndOfCommands /dev/null1$ command &gt; /dev/null 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出“的效果。 Shell文件包含1234# Shell 中包含脚本可以使用. filename# ORsource filename Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。 被包含脚本不需要有执行权限。 例子： 123#!/bin/bash. ./subscript.shecho $url 参考： Linux Shell脚本教程：30分钟玩转Shell脚本编程(笔记) 30分钟玩转Shell脚本 Linux Shell脚本教程：30分钟玩转Shell脚本编程 Shell脚本编程30分钟入门]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mat不lab]]></title>
    <url>%2F2017%2F04%2F19%2FMat%E4%B8%8Dlab%2F</url>
    <content type="text"><![CDATA[这篇文档主要记录一些常见但是我还没有掌握的matlab用法，毕竟小白，所以还是多记为妙～ 20170418 - matlab 二进制文件读写 读入二进制文件 - fread 1234567% 打开二进制文件% 将文件数据读入变量f中：一维方式存储在f中，num是文件中的数据个数% 关闭文件fip=fopen('test2.out','rb');[f,num]=fread(fip,50*504,'float');fclose(fip) 写出二进制文件 - fwrite 1234567891011% 打开二进制文件% 将变量数据写入文件中：一维方式存储在文件中% 关闭文件fid=fopen('V1_01.dat','wb');for j=1:1:300 for i=1:1:2500 fwrite(fid,a(i,j),'float'); endendfclose(fid); 20170418 - matlab中让人相见恨晚的命令 dbstop if error：如果运行出现错误，matlab会自动停在出错的那行，并且保存所有相关变量。 不用设置断点； 为避免每次在命令行中都要敲入，可以在主函数最前面加入该语句； 退出需要执行dbquit 未完待续 20140418 - matlab avi动画制作 VideoWrite函数，配合open,writeVideo和close方法从图像(figure)中创建视频文件、静态图像或Matlab视频。VideoWrite函数可以创建AVI和Motion JPEG 2000格式的视频文件，这些文件在多平台上都能播放，也可以创建在window平台上播放的MPEG-4文件。VideoWrite函数支持大于2GB的视频文件。VideoWrite函数使用预先定义的属性来设置视频属性，例如’Uncompressed AVI’ or ‘MPEG-4’等。 工具函数 - VideoWriter() 1writerObj = VideoWriter(filename,profile); filename：单引号引用的字符串指定视频文件名。文件名可以加扩展名，也可以不加扩展名。Matlab支持的视频文件扩展名如下： .avi ：avi file .mj2：Motion JPEG 2000 file .mp4 or m4v：MPEG-4 file (Win7 system only) Tip：如果文件名不指定扩展名，VideoWrite函数将根据profile的设置来自动加上.avi，.mj2，.mp4 或者.m4v的扩展名，如果没有设置profile的值，VideoWrite函数默认保存为.avi文件。 profile：使用单引号引用的字符串，描述了创建视频的类型。 ‘Archival’ ‘Motion JPEG AVI’ ‘Motion JPEG 2000’ ‘MPEG-4’ ‘Uncompressed AVI’ 函数方法 open：Openfile for writing video data 打开视频 getProfiles：List profiles and file formats supportedby VideoWriter 列出VideoWriter支持的配置和文件格式 writeVideo：Write video data to file 写视频 close：Closefile after writing video data 写完视频数据后关闭文件 基本步骤 创建视频并打开该视频文件 12writerObj=VideoWriter('test.avi'); %// 定义一个视频文件用来存动画 open(writerObj); %// 打开该视频文件 在循环中获取图像中的帧 1frame = getframe; %// 把图像存入视频文件中 将帧写入视频文件 1writeVideo(writerObj,frame); %// 将帧写入视频 循环结束后关闭视频文件 1close(writerObj); %// 关闭视频文件句柄 其他设置 改变帧数 12% 此语句必须在open语句之前writerObj.FrameRate=2; % 默认30，即1秒30幅图 改变像素尺寸 123frame = getframe; frame.cdata = imresize(frame.cdata, [H W]); %// 设置视频宽高：H为行数(高)，W为列数(宽) writeVideo(writerObj,frame); VideoWrite()函数默认根据第一帧的大小决定保存视频高和宽，并且没有给出自定义视频尺寸的方法。网上搜了很久，没有找到如何改变保存视频像素尺寸的方法。设置断点调试，发现frame=getframe;获取的帧frame为一个结构体，包含两个成员： cdata为数据，colormap为调色板。cdata的尺寸378×607就是第一帧读取的图像的尺寸，VideoWrite()函数将默认以该尺寸保存所有图像帧到视频文件。 有时，图像绘制过程中，如果曲线的尺寸会随时间变化：变小不会有问题，而如果曲线尺寸超过378×607就会出错。为了避免因此造成的错误，可以通过在读完每一帧后改变该帧的尺寸，来实现将视频保存成自定义的长宽，不足的部分自动用figure的底色填充。 注意：matlab是区分大小写的，所以这里用的VideoWriter()以及writeVideo中的大小写不可随意改变。 参考： Matlab—将绘图保存为视频VideoWrite()函数用法与自定义视频尺寸 help VideoWriter 2017 - 05 - 04 matlab中的Renderer1.首先解释下什么是Renderer：A renderer is the software that processes graphics data (such as vertex coordinates) into a form that MATLAB can use to draw into the figure. MATLAB supports three renderers:1) Painters2) Z-buffer3) OpenGLRenderer(扫描器)是一种图像数据转换程序，通过这个程序，可以把图像数据转化为Matlab可以用来画图的内容。可以这样理解：Renderer(渲染器，描绘器)是matlab用来画图（即将数据转化为图像）的方式。它三种方式：1）Painters 2) Z-buffer 3) OpenGL 2.三种方式的比较1)painters 再画简单的图画时，比较快；2)z-buffer 又称深度缓冲技术，它是现在内存中画图，然后再将最终的图像显示在显示终端。这样的话，当在一个像素点，如果被多次赋值的话，它只会显示最高层的图像。3) opengl 是利用硬件进行绘图的方式。 2017 - 05 - 10 matlab中不同长度字符串数组使用cell数组，关键点：{ } 元胞数组是MATLAB的一种特殊数据类型，可以将元胞数组看做一种无所不包的通用矩阵，或者叫做广义矩阵。组成元胞数组的元素可以是任何一种数据类型的常数或者常量，每一个元素也可以具有不同的尺寸和内存占用空间，每一个元素的内容也可以完全不同，所以元胞数组的元素叫做元胞（cell）。和一般的数值矩阵一样，元胞数组的内存空间也是动态分配的。 12345678for i=1:1:mpx for j=1:1:mpy for k=1:1:mpz fnm_out&#123;ii&#125;=char([fnm_out 'sgt_00' num2str(id) '_mpi0' px(i) '0' py(j) '0' pz(k) '_n00001.nc']); ii=ii+1; end endend 参考： Matlab字符串数组 matlab的cell数组 2017 - 06 - 11 matlab中的字体设置 通用格式 1title(['\fontsize&#123;6&#125;\fontname&#123;宋体&#125;中文\fontsize&#123;7.5&#125;\fontname&#123;the new time&#125;english']); 采用句柄设置 1set(gca,'FontSize',20); ​]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FD3D运行大全]]></title>
    <url>%2F2017%2F03%2F30%2FFD3D%E8%BF%90%E8%A1%8C%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Please enter the password to read. 解密 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]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pocket~]]></title>
    <url>%2F2017%2F03%2F23%2FPocket%2F</url>
    <content type="text"><![CDATA[Please enter the password to read. 解密 U2FsdGVkX19SndLfkrDX2IrXszjhO8c7d9FmPpPdYf5x7ac47quTpERal+ObP5XgCAzSwHFxdWn0ePqMn1InUBdciCmmtnZU+cjUWaonzcT9LUG6C8om4du3TWZpSm08gQqwJKcELc3FOTLHasC4K+SWyDuO7pk5Z2BUge9Q32rqJMceOk3jiaV9nLtwHnpVRtt8DWkTNpi2kepaFMrPnhEtXkPmjCQz6UCa2DowotmA6crQl9/iEy3XWA3HztOxm0rTJR5kcBN5etYWNI3S+3oS2yRNa/EzMsh0laNYbWwrU9o2H2aTmy1r883Em5+/T3poqr+IetoD7TdOymgraJtbNmjbQJCRcaF93Xcbqy0Wez7Ai7CTzumhbvdylO2BEeAt4eSS6/FH1sZVtuAYfMyfUGv9GP3OwhzovbUx+8bDkifkgLRpPhTjfCgRIfGyQ6H7Ki0W16as2vdKU9X3LopM/9WUO/cPlljRvgD4y7107B77tBkFxu5kjF4ATRlf7hGsk8+Sk/OyljSoxbe9yFhyi0zbijvKKUZLxs6fzWagfPqzfPfR+XqpQu/VS1uVpESjnwDXQpjHC4vP7/5JPYFESj4bittbsry0Gxo4DaZZwks0tpwX62kjtRYCjGPCsNCtzMbka+Lusm1UYVILVmhXy70hxYkDdjwPB5+nKrkez6gosh86t9Fc29AVp37PMkKkdRDAI1tqHlTrMiczuuWTOl2yYiHU1+4tOmfVBjAtXKPb9cZSCzfoaAYlvNtfDyRAFep43r909HdDr5g21ayhHfbr2QGRCDvXbTs0O/iBlSFnk8GQ7AshTTNvWz7PNpPMWT5VUdMmDWNYeM9217H4wxUyqmxOabAUCg6ncATc3XmcDhxfUiWmyl4uy1kuIwk+PC64dhBjfSMqek8/bSYgDnF4tPTz3O2DzGgiV30Yg801XSKw+z1TDoF20Ab/jpIRNaRscJOO9QH2mpKdMoXfxm1dG92cQIa6l3JerUd0pWpN8rKEItRVE4xkJIe0qmqBZo28tsMfIfQ6ZjJYNv/9BiaUBxeBZsGN7WokapsC2FW3DPPGNvsiM7qBHMX2F4xwiVoRxJiLd/CMqlVwFBMR2Z0itWszF17Rwu+NftSTsysJtfU7BXZMcCcSiwOAhRMzD4XSXR8xjNcAF9UCZdVl8mEYZ7qyb1jkSwisS5JzONk8pRI0Hd61WNHJPTKGSV+6/97StzA5ia5dc5V6yfkzV2ugf2+TWaOH2/WRaw8XAzryUvUlUoIuU4ehi+IP8VIBUa8bNLgSSY0Y8/Ver9+pkTonE9Ri0WdHu1LYdQDSi3BMDukI6dy/as2bpTfgJO7djM1XoWUX2szf0dRKPiOsKI523YzTtZLAOAuE+OZV5/A1pUgtSFxnLfP8DaZxkonEZkxR4ZPquEqyD19+W0QNQX5m2E7jnCVGJBEEKA5vwFLa6pOopN/dEB0xOAVunmDNGPbzb81Gei9R3Hwnjg==]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>稍后</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim插件进阶]]></title>
    <url>%2F2017%2F03%2F16%2Fvim%E6%8F%92%E4%BB%B6%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[这篇文档主要对vim学习过程中使用的插件进行归档学习。 代码分析tagbar 项目地址：https://github.com/majutsushi/tagbar](https://github.com/majutsushi/tagbar) 基本使用方法： 需要先用ctags程序在目标文件夹下生成tags文件 Ctrl + [ (上一个标签) Ctrl + ] (下一个标签) Ctrl + T (回到第一个标签) 注意事项 在vim中安装tagbar后，需要在.vimrc中设置相关的快捷键 1nmap &lt;F8&gt; :TagbarToggle&lt;CR&gt; ​]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混合编程注意事项]]></title>
    <url>%2F2017%2F03%2F15%2F%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[这篇文档主要对C和Fortran混合编程的注意事项做一个补充。 &lt;!—more—&gt; 函数还是子例程函数在C和Fortran中有不同的含义： 在 C 中，所有的子程序都是函数(function)；但 void 函数不会返回值。 在 Fortran 中，函数(function)会传递一个返回值，但子例程(subroutine)一般不传递返回值。 因此， 当 Fortran 例程调用 C 函数时： 如果被调用的 C 函数返回一个值，则将其作为函数从 Fortran 中调用。 如果被调用的 C 函数不返回值，则将其作为子例程调用。 当 C 函数调用 Fortran 子程序时： 如果被调用的 Fortran 子程序是一个函数，则将其作为一个返回兼容数据类型的函数从 C 中调用。 如果被调用的 Fortran 子程序是一个子例程，则将其作为一个返回 int（与 Fortran INTEGER*4 兼容）或 void 值的函数从 C 中调用。 数据兼容性 可以参考前一篇文档的数据类型对应关系 不能按值传递数组、字符串或结构 在Fortran中字符串数组长度固定，没有结束符，在C中，字符串长度可变，同时需要有一个结束符’\0’ 大小写问题： Fortran大小写不敏感，可以任意使用 C对大小写敏感，因此建议在C程序中，函数名全为小写 例程名中的下划线Fortran 编译器通常会在入口点定义和调用中都出现的子程序名末尾追加一个下划线 (_)。该惯例不同于具有相同的用户指定名称的 C 过程或外部变量。几乎所有 Fortran 库过程名都有两个前导下划线，以减少与用户指定的子例程名的冲突。解决方案： 在 C 函数中，通过在函数名末尾追加下划线来更改该名称。 使用 BIND(C) 属性声明来指明外部函数是 C 语言函数。 使用 f95 -ext_names 选项编译对无下划线的外部名称的引用。 上面的方法只能3选1，一般采用的是第一种，第三种使用不广泛，第二种可以如下示例使用。 123FUNCTION ABC EXTERNAL XYZ BIND(C) ABC, XYZ BIND(C) 声明可从 Fortran 调用的 C 外部函数，以及可从 C 中作为参数调用的 Fortran 例程。Fortran 编译器在处理外部名称时通常不追加下划线。BIND(C) 必须出现在每个包含这样的引用的子程序中。在此处，用户不仅指定 XYZ 是外部 C 函数，而且还指定 Fortran 调用程序 ABC 应该可以从 C 函数调用。如果使用 BIND(C)，C 函数不需要在函数名末尾追加下划线。 数组索引与顺序Fortran 与 C 的数组索引和顺序不同。 数组索引C 数组总是从 0 开始，而 Fortran 数组在缺省情况下是从 1 开始。有两种常用的索引处理方法： 可以使用 Fortran 缺省设置。 可以指定 Fortran 数组 B 以 B(0) 开始，如INTEGER B(0:2) 数组顺序 Fortran 数组按列主顺序存储：A(3,2) 1A(1,1) A(2,1) A(3,1) A(1,2) A(2,2) A(3,2) C 数组按行主顺序存储：A[3][2] 1A[0][0] A[0][1] A[1][0] A[1][1] A[2][0] A[2][1] 这对于一维数组不存在任何问题。但对于多维数组，应注意下标在所有引用和声明中是如何出现和使用的－可能需要做些调整。 例如，在 C 中进行部分矩阵操作，而后在 Fortran 中完成余下部分，这样做可能会产生混淆。最好是将整个数组传递给另一语言中的例程，然后在该例程中执行所有矩阵操作，以避免在 C 和 Fortran 中各执行部分操作的情况。 参数传递按引用传递参数 简单数据类型（非COMPLEX或CHARATER串） C调用Fortran，实参使用指针（&amp;a），形参不需要特殊说明，默认为引用 Fortran调用C，实参不需要特殊说明，默认为引用，形参使用指针（*a） COMPLEX 将 Fortran COMPLEX 数据项作为指针传递到具有两种浮点或两种双精度数据类型的 C 结构体 字符串 由于没有标准接口，因此不推荐在 C 与 Fortran 例程间传递字符串。 一维数组 C调用Fortran，传递地址 Fortran调用C，传递引用（默认不需更改） 二维数组 注意行列转换，实质就是一个是(i, j ,k)，另外一个是(k, j, i) 结构体 只要相应的元素是兼容的，便可以将 C 和 Fortran 95 派生类型传递给彼此的例程。f95 接受传统的 STRUCTURE 语句 Fortran 95 标准要求派生类型定义中有 SEQUENCE 语句，以确保编译器保持存储序列的顺序。 指针（传递指针就会在C中形成指针的指针） 由于 Fortran 例程按引用传递参数，因此可将 FORTRAN 77 (Cray) 指针作为指针的指针传递给 C 例程。 C 指针与 Fortran 95 标量指针兼容，但与数组指针不兼容。 Cray 与 Fortran 95 指针间的主要区别是 Cray 指针的目标始终是已命名的。在许多上下文中，声明 Fortran 95 指针会自动标识其目标。另外，被调用 C 例程还需要显式 INTERFACE 块。 按值传递参数 从 C 中调用时，Fortran 95 程序应在伪参数中使用 VALUE 属性，并且应为从 Fortran 95 中调用的 C 例程提供一个 INTERFACE 块 在 C 与 Fortran 95 之间传递简单数据元素 对于传统 Fortran 77，按值调用仅对简单数据可用，并且只能为调用 C 例程的 Fortran 77 例程所用。无法做到让 C 例程调用 Fortran 77 例程并按值传递参数。数组、字符串或结构最好是按引用传递。 要将值从 Fortran 77 例程传递到 C 例程，请使用非标准 Fortran 函数 %VAL(arg) 作为调用中的一个参数。 返回值类型返回简单数据类型直接返回 返回COMPLEX数据具体参见Here，11.5.2部分 返回CHARACTER串不建议传递字符串，具体参见Here，11.5.3部分 参考： C-Fortran 接口]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Fortran</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C与Fortran混合编程]]></title>
    <url>%2F2017%2F03%2F15%2FC%E4%B8%8EFortran%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这篇文档主要是对C和Fortran的混合编程实现进行一个大致的学习与归纳。目前在work中主要是利用Fortran调用C函数。 基本概况由于 GNU 的 Fortran 和 C 语言二者的函数彼此可以直接相互调用，所以混合编程可以非常容易地实现。只要你足够仔细，确保函数调用时传递的参数类型正确，函数就可以在两种语言间来回调用，就像它们是同一种语言一样。 下表中列出了 Fortran 的数据类型和它们在 C 中对应的类型。这张表在大多数平台下是没问题的，但是或许会有例外的情况发生。在你打算传递某种数据类型时，先编写一个简单的例子进行测试将是很明智的。 注意： 由于 Fortran 总是以引用的方式传递参数，而 C 则始终以地址方式传递数组，因此数组做参数时不需做任何修改。但是对多维数组来说，混合调用时其下标需要翻转，因为 Fortran 的数组是以列为主序（column-major order）而 C 数组以行为主序（row-major order）。 实例分析简单案例Fortran调用C函数 主程序 1234567891011121314! C 表示注释C fortran2c.fC PROGRAM FORTRAN2CC CHARACTER*32 HELLO REAL PIC HELLO = &quot;Hello C from Fortran&quot; HELLO(21:21) = CHAR(0)C HELLO(21) = CHAR(0) PI = 3.14159 CALL SHOWHIPI(HELLO,PI) END PROGRAM FORTRAN2C Tips： 可存储32个字符的 CHARACTER 型字符串变量 HELLO 中，存有 21 个字符，剩余部分用空格填充。 要将该字符串格式化为 C 语言标准的字符串，我们必须在实际字符串结束的位置插入一个 ascii 码为“0”字符作为结束标志。 REAL 型浮点数 PI 存储方式和 C 中 float 型变量完全一样，因此可以直接传递给函数。 理解 Fortran 的参数总是通过引用传递是非常重要的，因此 C 函数接收到的总是被传递的变量的地址而不是变量值本身。 调用程序 123456/* showhipi.c */#include &lt;stdio.h&gt;void showhipi_(char *string,float *pi)&#123; printf("%s\nPI=%f\n",string,*pi);&#125; Tips： 在不同的平台下 Fortran 和 C 语言的命名惯例和数据类型的匹配关系是不同的。如同你在本例中看到的，在函数名后添加一下划线是必须的。 编译运行 12345$ gfortran -c fortran2c.f -o fortran2c.o$ gcc -c showhipi.c -o showhipi.o$ gfortran fortran2c.o showhipi.o -o fortran2c# OR$ gcc fortran2c.o showhipi.o -o fortran2c -lgfortranbegin -lgfortran Tips： gfortran只是gcc的一个前端 C调用Fortran函数 主程序 12345678910111213/* c2fortran.c */int main(int argc,char *argv[])&#123; int i; float e = 2.71828; char hello[32]; int length = sizeof(hello); strcpy(hello,"Hello Fortran from C"); for(i=strlen(hello); i&lt;length; i++) hello[i] = ' '; showhie_(hello,&amp;length,&amp;e); return(0);&#125; Tips： 在 C 中，字符串的长度是由 null 字符的位置决定的，但在 Fortran 中，所有字符串的长度都是固定的。 由于 Fortran 没有办法确定传递给它字符串的长度，我们必须将字符串长度作为参数同时传递。本例中，字符数组用空格填充，数组大小作为第二个参数传递。 注意到三个参数都是通过指针传递的──因为 Fortran 总是期待地址而不是真实的值。 在被调用的子程序名后添加一下划线通常是必须的。 调用程序 1234567891011C showhie.fC SUBROUTINE SHOWHIE(HELLO,LENGTH,E) CHARACTER*(*) HELLO INTEGER LENGTH REAL EC WRITE(*,100) HELLO(1:LENGTH),LENGTH,E 100 FORMAT(3X,A,2X,I3,4X,F6.4) RETURN END SUBROUTINE SHOWHIE 编译运行 12345$ gfortran -c showhie.f -o showhie.o$ gcc -c c2fortran.c -o c2fortran.o$ gfortran c2fortran.o showhie.o -o c2fortran# OR$ gcc fortran2c.o showhipi.o -o fortran2c -lgfortranbegin -lgfortran 重点探讨混合语言编程要注意的问题主要体现在： 函数调用和数据结构的存储。 注意及范例注意事项： 在C与Fortran中数组存放顺序不同，因此，传送后必须进行转置 在C中数组元素下标从0开始，而在Fortran中则从1开始 在C与Fortran中传递的数组大小、类型必须完全相同、对应 在C中，形参中的数组元素不能采用动态数组，即不能用malloc分配内存 数组顺序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* Fortran为主程序调用C子程序的例子如下: */program testexternal get3ddimension u(12,11,10) imax=10jmax=11zmax=12ii=20x=200.0! 传递时需要将ijk转为jkicall get3d(imax,jmax,kmax,delx,bb,ii,x)write(*,*) 'in F:', imax,jmax,kmax,delx,ii,xdo k=1,kmax do j=1,jmax do i=1,imax write(*,*) i,j,k,u(k,j,i) enddo enddoenddo end-------------------------------------------#include #include void get3d_(int *LEN,int *DEP,int *HIG,float *deltaX, \float u[12][11][10],int *ii,float *x)&#123; int i,j,k; *LEN=12; *DEP=11; *HIG=10; *deltaX=1.0; for (k = 0; k &lt; *HIG; k++) &#123; for (j = 0; j &lt; *DEP; j++) &#123; for (i = 0; i &lt; *LEN; i++) &#123; u[i][j][k] = (float)(i+j+k); printf("in C1: %f\n",u[i][j][k]); &#125; &#125; &#125; printf("%d %f %d %f\n",*LEN,*DEP,*HIG,*deltaX,*ii,*x);&#125; 元素下标12345678910111213141516171819202122232425262728293031323334353637383940414243/* C为主程序调用Fortran子程序的例子如下: */#include #include int main()&#123; extern void get3d_(int *LEN,float *deltaX,float bb[10],int *j,float *x); int i,j,LEN; float x,deltaX,bb[10]; LEN=325; deltaX = 1.0; for(i=0;i&lt;10;i++) &#123; bb[i]=i; printf("in C1: %f\n",bb[i]); &#125; printf("in C1: %d %f\n",LEN,deltaX); get3d_(&amp;LEN,&amp;deltaX,bb,&amp;j,&amp;x); printf("in C2: %d %f %d %f\n",LEN,deltaX,j,x); // 下标从0开始，[0:9] for(i=0;i&lt;10;i++)&#123; printf("in C2: %f\n",bb[i]); &#125;&#125;-------------------------------------------subroutine get3d(imax,delx,bb,j,x)dimension bb(10) j=20x=200.0! 下标从1开始，[1:10]do i=1,10 bb(i)=bb(i)+1enddo write(*,*) 'in F:', imax,delx,j,xwrite(*,*) 'in F:', bb end 其他123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* C调用Fortran: */#include void sub_fortran_(int *,float *,double *); double function_fortran_(double *); int main() &#123; int num_int; float num_float; double num_double; double num; num_int=3; num_float=5.0; sub_fortran_(&amp;num_int,&amp;num_float,&amp;num_double); num=function_fortran_(&amp;num_double); printf("num_int=%d\nnum_float=%f\nnum_double=%f\nnum=%f", \num_int,num_float,num_double,num); return 0; &#125;-------------------------------------------/* Fortran90: */subroutine Sub_Fortran(NumInt,NumFloat,NumDouble) implicit none integer :: NumInt real :: NumFloat real(8) :: NumDouble NumDouble=NumFloat**NumInt end subroutine real(8) function Function_Fortran(NumDouble) implicit none real(8) :: NumDouble Function_Fortran=sqrt(NumDouble) end function-------------------------------------------/* Fortran2003: */subroutine Sub_Fortran(NumInt,NumFloat,NumDouble) use ISO_C_BINDING implicit none integer(c_int) :: NumInt real(c_float) :: NumFloat real(c_double) :: NumDouble NumDouble=NumFloat**NumInt end subroutinereal(c_double) function Function_Fortran(NumDouble) use ISO_C_BINDING implicit none real(c_double) :: NumDouble Function_Fortran=sqrt(NumDouble) end function-------------------------------------------链接方法:gcc –o main.o –c main.cgfortran –o sub.o –c sub.f90gcc –o main.exe main.o sub.o或者直接 gcc –o main.exe main.c sub.f90 ========================================================= /* Fortran调用C: Fortran90: */! main fortranprogram main implicit none! 函数接口interfacesubroutinesubroutine sub_c(n1,n2,n3) integer :: n1 real :: n2 real(8) :: n3 end subroutine real(8) function func_c(n3) real(8) :: n3 end function end interface integer :: n1 real :: n2 real(8) :: n3,n4 n1=3 n2=5.0 call sub_c(n1,n2,n3) n4=func_c(n3) write(*,*) "n1=",n1 write(*,*) "n2=",n2 write(*,*) "n3=",n3 write(*,*) "n4=",n4 end program-------------------------------------------/* Fortran2003: */program main use ISO_C_BINDING implicit none! 函数接口interface subroutine sub_c(n1,n2,n3) use ISO_C_BINDING integer(c_int) :: n1 real(c_float) :: n2 real(c_double) :: n3 end subroutinereal(c_double) function func_c(n3) use ISO_C_BINDING real(c_double) :: n3 end function end interfaceinteger(c_int) :: n1 real(c_float) :: n2 real(c_double) :: n3,n4 n1=3 n2=5.0 call sub_c(n1,n2,n3) n4=func_c(n3) write(*,*) "n1=",n1 write(*,*) "n2=",n2 write(*,*) "n3=",n3 write(*,*) "n4=",n4 end program-------------------------------------------/* 调用C程序 */#include &lt; math.h &gt; void sub_c_(int *,float *,double *); double func_c_(double *); void sub_c_(int *n1,float *n2,double *n3) &#123; *n3=pow(*n2,*n1); &#125; double func_c_(double *n3) &#123; double n4; n4=sqrt(*n3); return n4; &#125;-------------------------------------------链接方式:gcc –o sub.o sub.cgfortran –o main.o main.f90gfortran –o main.exe main.o sub.o或是直接gfortran –o main.exe main.f90 sub.c 函数调用 对于有返回值调用，二者的返回值数据类型必须一致。 Fortran调用例程时，实参和形参默认是引用传递，而C则是值传递。 如果二者均采用默认的调用方式，那么Fortran调用C函数 时，C的形参应该声明为指针类型（*）；C调用Fortran函数时，C传递实参时须以&amp;形式传递变量地址。 传递数组时，二者均使用数组首地址作为参数，因此无需转换。如果C的参数本身为指针变量，也不需要转换。 参考： Mix C Fortran C与FORTRAN混合编程2 C/Fortran混合编程 混合语言编程]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Fortran</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中的函数库]]></title>
    <url>%2F2017%2F03%2F08%2FLinux%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BA%93%2F</url>
    <content type="text"><![CDATA[这篇文档主要对Linux系统中静态库和动态库进行一个比较系统的学习。 Linux下的函数库分类linux下的库有两种：静态库和共享库（动态库）。 二者的不同点在于代码被载入的时刻不同： 静态库的代码在编译过程中已经被载入可执行程序，运行时将不再需要该静态库，因此体积较大。 共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。 命名在linux下，库文件一般放在/usr/lib和/lib下， 静态库的名字一般为libxxxx.a，其中xxxx是该lib的名称 动态库的名字一般为libxxxx.so.major.minor，xxxx是该lib的名称，major是主版本号， minor是副版本号 动态库的三个名字： “real name”：实际的文件名，这是实际生成的库文件，一般命名为libXXX.so.X.Y.Z 其中XXX是自定义的名字，后面的X，Y，Z是用数字表示的版本号 X是主版本号，一般在库的接口发生改变，无法兼容的时候，更新这个数字 Y是次版本号，如果接口没有改变，只是升级算法，或者增加新接口，更新这个数字 Z是build版本号，一般每升级一次加1，也可以省略 “soname”：共享库的一个特殊的名字，在每个共享库生成的时候，一般会指定这个名字 一般命名为libXXX.so.X，其实就是上面的real name去掉最后两个版本号 每一个程序，在编译的时候，会指定一个他需要的共享库的soname，程序在启动的时候，由系统自动找到一个合适的共享库来使用 从前面可以看出，X是主版本号，一般接口有改变，无法保持兼容，才会更改这个数字，所以，soname就要指定这个数字，避免由于接口改变导致运行错误 “link name”：这个是在编译可执行程序的时候，使用的名字，如果要自己编译程序，就需要关心这个名字。比如我们在编译需要用到数学库的程序时，需要加上-lm参数，这个参数的意义就是，编译器会去寻找libm.so这个共享库（或者libm.a这个静态库，这个不是本文重点），这里的libm.so就是link name，命名的规则很明显，就是把soname后面的版本也去掉，只保留libXXX.so 一般用readelf -d libXXX.so.X.Y.Z来查看一个共享库文件的soname，其实real name和soname真正的对应关系是用这个命令来看的 Static Library创建详细创建过程可以参见：Linux编译器学习 12345# 创建gcc hello.c -o hello.o #这里没有使用-shared ar -r libhello.a hello.o #这里的ar相当于tar的作用，将多个目标打包。# 编译链接gcc main.c -lhello -L. -static -o main #-static也可以不加 Shared Library创建详细创建过程可以参见：Linux编译器学习 1234567# 创建gcc -fPIC -shared hello.c -o libhello.so # 编译链接gcc main.c -L. -lhello -o main # 运行export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:././main 注意： 创建时的选项-fpic，-shared，其中-fpic还有-fPIC形式，区别在于-fPIC生成的库比较大，比较通用，-fpic生成的可能受平台限制较大 编译链接时需要指定位置，可以使用-L或是添加环境变量LIBRARY_PATH的方式来将相关库文件包含到搜索路径中，然后还需要通过-l指定函数库，使用到gcc非标准内置函数库时需要加上-lm选项 运行前需要将库函数添加到路径中，一般都是通过改变LD_LIBRARY_PATH来实现路径的包含，更多可见Linux环境变量及编译器库路径 可以通过自带的ldd命令来分析动态库的链接情况，如果目标程序没有链接动态库，则打印“not a dynamic executable” 对于Gfortran的一些建议 -l library 选项的命令行顺序 将 -llibrary 选项放置在任一 .f、.for、.F、.f95 或 .o 文件之后。 如果调用了 libx 中的函数，并且这些函数引用了 liby 中的函数，则将 -lx 置于 -ly 之前。 -L dir 只有将其放在它所应用的 –llibrary 选项之前，该选项才有用。 库搜索路径和顺序－动态链接 在生成时指定动态库： 1f95 program.f -R/home/proj/libs -L/home/proj/libs -lmylib 生成可执行文件时，链接程序会在可执行文件本身中记录共享库的路径。这些搜索路径可以用 -Rpath 选项指定。这一点与 -Ldir 选项相反，该选项在生成时指示到哪里查找 -llibrary 选项所指定的库，但不会将该路径记录到二进制可执行文件中。 在运行时指定动态库：修改LD_LIBRARY_PATH 参考： Linux GCC编译使用动态、静态链接库 Linux下Gcc生成和使用静态库和动态库详解 共享库的生成与使用]]></content>
      <categories>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux编译器学习]]></title>
    <url>%2F2017%2F03%2F07%2FLinux%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这篇文档主要对gcc静态函数库（static library）以及动态函数库（shared library）的编译生成以及使用进行一个简短的学习。 GCC函数库基础知识 C编程中的相关文件后缀 | 后缀 | 文件 || :–: | ————- || .a | 静态库 || .c | C源代码（需要编译预处理） || .h | C源代码头文件 || .i | C源代码（不需编译预处理） || .o | 对象文件 || .s | 汇编语言代码 || .so | 动态库 | 常用编译运行模式 1234# 编译链接gcc -Wall helloubuntu.c -o helloubuntu# 运行./helloubuntu 注意： 若用到math.h库等非gcc默认调用的标准库，请使用-lm参数 常见编译器选项： -c：只编译生成目标文件，默认的输出文件的文件名同源代码文件名一致 -Wall：生成所有警告信息 -w：不显示任何警告信息 -g：生成调试信息 -lLIBRARY： 连接时搜索指定的函数库LIBRARY。 -LDIRECTORY： 指定额外的函数库搜索路径DIRECTORY。 -IDIRECTORY ：指定额外的头文件搜索路径DIRECTORY。 -o：指定生成的对象的文件名 -O[0-3]：数字越大，优化等级越高 -E：只进行编译预处理，若不指定输出对象，那么结果将在标准输出中列出，可以 1$ gcc -E helloubuntu.c -o helloubuntu.i -S：指示编译器生成汇编语言代码然後结束 1$ gcc -S helloubuntu.c 静态库创建静态库是编译器生成的普通的.o文件的集合。链接一个程序时用库中的对象文件还是目录中的对象文件都是一样的。静态库的另一个名字叫归档文件(archive)，管理这种归档文件的工具叫ar 。 1234567891011# 要构建一个库，首先要编译出库中需要的对象模块（也就是采取只编译不链接的命令）gcc -c -Wall hellofirst.c hellosecond.c# 程序 ar 配合参数 -r 可以创建一个新库并将对象文件插入。如果库不存在的话，参数 -r 将创建一个新的，并将对象模块添加（如有必要，通过替换）到归档文件中。ar -r libhello.a hellofirst.o hellosecond.o# 程序 twohellos 可以通过在命令行中指定库用一条命令来编译和链接gcc -Wall twohellos.c libhello.a -o twohellos# OR # 静态库的命名惯例是名字以三个字母 lib 开头并以後缀 .a 结束。所有的系统库都采用这种命名惯例，并且它允许通过 -l(ell) 选项来简写命令行中的库名。gcc -Wall twohellos.c -lhello -o twohellos 注意： 上述两条命令效果相同，但是gcc找寻libhello.a的库的位置不同 指定完整的路径名可使编译器在给定的目录中寻找库。库名可以指定为绝对路径（比如 /usr/worklibs/libhello.a）或者相对与当前目录的路径（比如 ./lib/libhello.a） 选项-l 不具有指定路径的能力，但是它要求编译器在系统库目录下找寻该库。 选项-L可以指定具体的目录，使编译器在搜寻系统库目录前先搜寻此目录 12# 假设libhello.a 在当前目录的lib文件夹下。gcc -Wall -L ./lib/ twohellos.c -lhello -o twohellos 共享库构建共享库是编译器以一种特殊的方式生成的对象文件的集合。对象文件模块中所有地址（变量引用或函数调用）都是相对而不是绝对的，这使得共享模块可以在程序的运行过程中被动态地调用和执行。 12345678910111213141516171819# 要构建一个共享库，首先要编译出库中需要的对象模块# -c：只生成 .o 的对象文件# -fpic：使生成的对象模块采用浮动的（可重定位的）地址，缩微词pic代表“位置无关代码”（position independent code）gcc -c -Wall -fpic shellofirst.c shellosecond.c# 下面的 gcc 命令将对象文件构建成一个名为 hello.so 的共享库# -o：用来为输出文件命名# -shared：抑制错误选项# .so :通知编译器将对象文件链接成一个共享库gcc -Wall -shared shellofirst.o shellosecond.o -o hello.so## OR 以上两条命令合成一条gcc -Wall -fpic -shared shellofirst.c shellosecond.c -o hello.so# 程序可以用下面的命令编译并链接共享库gcc -Wall stwohellos.c hello.so -o stwohellos# 程序 stwohello 已经完成，但要运行它必须让其能定位到共享库 hello.so，因为库中的函数要在程序运行时被加载。 需要注意的是，当前工作目录可能不在共享库的查找路径中，因此需要使用如下的命令行设定环境变量LD_LIBRARY_PATHexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./ G++函数库基础知识 Cpp编程中的相关文件后缀 | 后缀 | 文件 || :————————–: | ————— || .C .c .cc .cp .cpp .cxx .c++ | C++源代码（需要编译预处理） || .h | C或者C++源代码头文件 || .ii | C++源代码（不需编译预处理） || .o | 对象文件 || .s | 汇编语言代码 || .a | 静态库 (archive) || .so | 动态库 || \ | 标准C++系统头文件 | 常用编译运行模式 1234# 编译链接g++ helloworld.cpp -o helloworld# 运行./helloworld 注意： 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示 12gcc helloworld.cpp -lstdc++ -o helloworld# 选项 -l (ell) 通过添加前缀 lib 和后缀 .a 将跟随它的名字变换为库的名字 libstdc++.a。而后它在标准库路径中查找该库。gcc 的编译过程和输出文件与 g++ 是完全相同的。 编译器选项与GCC完全相同 静态库创建同GCC 动态库创建同GCC Gfortran函数库基础知识 Gfortran编程中的相关文件后缀 | 后缀 | 文件 || —————————————- | ————————- || .f .for .FOR .ftn* .f90* .f95* .f03 | Fortran源代码（不需编译预处理） || .F .fpp .FPP .FTN .F90* .F95* .F03* | Fortran源代码（需要编译预处理） || .r | Fortran源代码（需要RatFor编译预处理） || .o | 对象文件 || .s | 汇编语言代码 || .a | 静态库 (archive) || .so | 动态库 | 注意：其中，标 * 的后缀名是gfortran的文件后缀，g77不能识别。 常用编译运行模式 1234# 编译链接gfortran helloworldff.f90 -o helloworldff# 运行./helloworldff 注意： 编译选项同GCC相同 类似g++ ，gfortran 也只是设置过 Fortran 程序所需基本环境的 gcc 的一个前端。当我们运行 gfortran 时，实际上运行并不是这个编译器，而是编译器驱动器。该驱动器解析命令行中所给出的选项，然后才调用真正的编译器，汇编器和链接器。默认情况下，编译器驱动器根据命令行中给定的文件的后缀决定它自己下一步的动作：一个名为 foo.c 将传递给 C 编译器，而名为 foo.f95 的文件将传递给 Fortran 95 的编译器，等等。 12# 类似于 g++gcc helloworld.f -o helloworld -lgfortran -lgfortranbegin ​ 静态库创建同GCC 动态库创建同GCC 参考： C编译初步 C++编译初步 Fortran编译初步 GCC 参数详解]]></content>
      <categories>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile学习笔记]]></title>
    <url>%2F2017%2F03%2F06%2FMakefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这篇文档主要是用作《跟我一起写Makefile》教程的笔记，不会面面俱到，只记录关键点。 &lt;!—more—&gt; [TOC] 概述 makefile的最大优点——自动化编译 make是一个命令工具，是一个解释makefile中指令的命令工具 程序的编译与链接 编译(compile)：由源文件生成目标文件(.o)，只要求 语法正确 函数和变量的声明正确（需要告诉编译器头文件的位置） 链接(link)：使用中间目标文件生成应用程序，也就是可执行文件 主要链接函数和全局变量，也就是要在目标文件中寻找函数的实现 一般情况下，我们都会对中间目标文件进行打包，在windows下形成库文件（library file），也就是.lib文件，而在linux下是Archive File，后缀为.a文件。 Makefile简介 make命令执行，需要有一个makefile文件 makefile规则12target ... : prerequisites ... command ... ... target ：可以是一个object ﬁle（目标文件）， 也可以是一个执行文件， 还可以是一个标签 （label）。 prerequisites ：生成该target所依赖的文件和/或target command：该target要执行的命令（任意的shell命令） 简言之：prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 makefile示例123456789101112131415161718192021222324edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c command.c display.o : display.c defs.h buffer.h cc -c display.c insert.o : insert.c defs.h buffer.h cc -c insert.c search.o : search.c defs.h buffer.h cc -c search.c files.o : files.c defs.h buffer.h command.h cc -c files.c utils.o : utils.c defs.h cc -c utils.c clean : rm edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 几个注意点： 反斜杠(\)是换行符 在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个 Tab 键作为开头。 clean只是一个label，make不会自动执行其后的命令，这样的方法非常有用，我们可以在一个makeﬁle中定义不用的编译或是和编译无关的命令，如打包备份等 工作流程 make会在当前目录下找名字叫“Makeﬁle”或“makeﬁle”的文件。 如果找到， 它会找文件中的第一个目标文件（target）， 在上面的例子中， 他会找 到“edit”这个文件，并把这个文件作为最终的目标文件。 如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比 edit 这个文 件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。 如果 edit 所依赖的 .o 文件也不存在，那么make会在当前文件中找目标为 .o 文件的依 赖性，如果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程） 当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生 成make的终极任务，也就是执行文件 edit 了。 make对于所定义的命令的错误，或是编译不成功，不会报错，只有依赖文件找不到时才会报错 Makefile中使用变量对于重复的字符串，我们可以使用变量避免重复书写。makeﬁle的变量也就是一个字符串，理解成C语言中的宏可能会更好。 变量定义： 12objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 变量使用：$(objects) Makefile自动推导GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令。 只要make看到一个 .o 文件， 它就会自动的把 .c 文件加在依赖关系中， 如果make找到 一个 whatever.o ， 那么 whatever.c 就会是 whatever.o 的依赖文件，并且 cc -c whatever.c 也会被推导出来，因而上面命令可以写为 123456789101112131415161718objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : defs.h kbd.o : defs.h command.h command.o : defs.h command.h display.o : defs.h buffer.h insert.o : defs.h buffer.h search.o : defs.h buffer.hfiles.o : defs.h buffer.h command.h utils.o : defs.h.PHONY : clean clean : rm edit $(objects) 也就是：对应于目标文件的源文件以及相应的编译命令cc -c都不需要显式写出。这就是所谓的隐晦规则。 清空目标文件的规则123.PHONY : clean clean : -rm edit $(objects) .PHONY表示clean是一个伪目标文件 在 rm 命令前面加了一个小减号的意思 就是， 也许某些文件出现问题， 但不要管， 继续做后面的事。 “clean从来都是放在文件的最后” makefile包含内容 显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makeﬁle的书写者明显 指出要生成的文件、文件的依赖文件和生成的命令。 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地 书写Makeﬁle，这是由make所支持的。 变量的定义。在Makeﬁle中我们要定义一系列的变量，变量一般都是字符串，这个有点像 你C语言中的宏，当Makeﬁle被执行时，其中的变量都会被扩展到相应的引用位置上。 文件指示。其包括了三个部分，一个是在一个Makeﬁle中引用另一个Makeﬁle，就像C语言 中的include一样；另一个是指根据某些情况指定Makeﬁle中的有效部分，就像C语言中的 预编译#if一样；还有就是定义一个多行的命令。 注释。Makeﬁle中只有行注释， 和UNIX的Shell脚本一样， 其注释是用 # 字符， 这个就 像C/C++中的 // 一样。 如果你要在你的Makeﬁle中使用 # 字符， 可以用反斜框进行转 义，如： # 。 Makefile文件名 建议使用Makefile这个作为文件名 可 以 使 用 别 的 文 件 名 来 书 写Makeﬁle， 比如：“Make.Linux”，等 ， 如 果 要 指 定 特定的Makeﬁle， 你可以使用make的-f和—file 参数，如： make -f Make.Linux 或make --file Make.AIX 引用其他Makefile 语法：include filename 注意点： filename 可以是当前操作系统Shell的文件模式（可以包含路径和通配符） 如果文件都没有指定绝对路径或是相对路径的话，make会 在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 如果make执行时，有 -I 或 –include-dir 参数，那么make就会在这个参数所指定的 目录下去寻找。 如果目录 \/include （一般是： /usr/local/bin 或 /usr/include ）存 在的话，make也会去找。 -include &lt;filename&gt;：无论include过程中出现什么错误，都不要报错继续执行。 Make工作方式 读入所有的Makeﬁle。 读入被include的其它Makeﬁle。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 书写规则参考：跟我一起写Makefile]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境变量及编译器库路径]]></title>
    <url>%2F2017%2F03%2F05%2FLinux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8F%8A%E7%BC%96%E8%AF%91%E5%99%A8%E5%BA%93%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[这篇文档主要对Linux下常见的环境变量做个大致的介绍，同时对gcc和gfortran的编译器库路径设置进行一个简单的学习。 &lt;!—more—&gt; Linux环境变量分类 根据生命周期可分 永久环境变量：修改配置文件生效 临时环境变量：利用export命令，仅在当前客户端下生效，关闭后失效 根据作用域可分 系统环境变量：对所有用户有效 用户环境变量：仅对特定用户有效 修改方式 vim /etc/profile：永久，系统 vim ~/.bashrc：永久，用户 export 变量名=变量值：临时（在当前终端输入） 注意：在文件中修改时需要export 变量名=变量值，保存退出后需要source /etc/profile或是source ~/.bashrc才能生效 常见变量 PATH：【一般用于添加可执行文件的路径】决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当运行一个程序时，Linux在这些目录下进行搜寻编译链接。定义格式： 1export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt; HOME：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）。 HISTSIZE：指保存历史命令记录的条数。 LOGNAME：指当前用户的登录名。 HOSTNAME：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的 SHELL：指当前用户用的是哪种Shell。 LANG/LANGUGE：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。 MAIL：指当前用户的邮件存放目录。 注意：上述变量的名字并不固定，如HOSTNAME在某些Linux系统中可能设置成HOST 变量操作 echo 显示某个环境变量值 echo $PATH export 设置一个新的环境变量 export HELLO=&quot;hello&quot; (可以无引号) env 显示所有环境变量 set 显示本地定义的shell变量 unset 清除环境变量 unset HELLO readonly 设置只读环境变量 readonly HELLO 参考： inux下查看和添加PATH环境变量 Linux环境变量总结 GCC编译器常用环境变量编译阶段 C_INCLUDE_PATH：gcc编译时查找头文件的目录 CPLUS_INCLUDE_PATH：g++编译C++文件时查找头文件的目录 LIBRARY_PATH：gcc和g++在编译的链接(link)阶段查找库文件的目录列表，在编译的时候需要指明所链接的库名，对于libxyz.a库，使用-lxyz指明即可 我们也可以在编译的时候用-L直接指定库文件目录，然后再使用-lxyz来实现库文件的链接 在这里库文件可以是静态的（static），也可以是动态的（shared）。 对于静态库文件，其代码在编译链接后会复制到程序中去，因此程序在运行的时候不必再次搜寻相应的库文件 对于动态库文件，在程序运行时需要动态链接到程序上，因此需要指定LD_LIBRARY_PATH路径 gcc编译、链接生成可执行文件时，动态库的搜索路径顺序如下： 1234# 不会递归在子目录下搜索1、gcc编译、链接命令中的-L选项；2、gcc的环境变量的LIBRARY_PATH（多个路径用冒号分割）；3、gcc默认动态库目录：/lib:/usr/lib:usr/lib64:/usr/local/lib。 运行阶段 LD_LIBRARY_PATH：程序运行时查找动态链接库(.so文件)的目录列表。 LD_PRELOAD：【不常见，优先加载指定的共享库】在LD_PRELOAD(参考man ld.so的LD_PRELOAD部分)中定义的动态链接库会在其他动态链接库之前被加载，因此会覆盖其他链接库里定义的同名符号（函数变量等）。需要注意的是，在C++中覆盖C函数库中的函数时，应使用extern &quot;C&quot;阻止Name Mangling。 Tips： 对于Debian系统，若是修改LD_LIBRARY_PATH无效，则可修改/etc/ld.so.conf或/etc/ld.so.conf.d/*.conf，将库目录作为一行加入以上的conf文件中，然后运行ldconfig命令即可。 修改/etc/ld.so.conf文件进行搜索路径的设置方式对于程序连接时的库（包括共享库和静态库） 的定位已经足够了，但是对于使用了共享库的程序的执行还是不够的。这是因为为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率， 所以是直接读取库列表文件 /etc/ld.so.cache ，从中进行搜索的。/etc/ld.so.cache 是一个非文本的数据文件，不能直接编辑，它是根据 /etc/ld.so.conf 中设置的搜索路径由 /sbin/ldconfig 命令将这些搜索路径下的共享库文件集中在一起而生成的（ldconfig 命令要以 root 权限执行）。因此，为了保证程序执行时对库的定位，在 /etc/ld.so.conf 中进行了库搜索路径的设置之后，还必须要运行 /sbin/ldconfig 命令更新 /etc/ld.so.cache 文件之后才可以。ldconfig ,简单的说，它的作用就是将/etc/ld.so.conf列出的路径下的库文件缓存到/etc/ld.so.cache 以供使用。 可执行文件运行时动态库搜索路径 12345671、编译目标代码时指定的动态库搜索路径：用选项-Wl,rpath和include指定的动态库的搜索路径，比如gcc -Wl,-rpath,include -L. -ldltest hello.c，在执行文件时会搜索路径`./include`；2、环境变量LD_LIBRARY_PATH（多个路径用冒号分割）；3、在 /etc/ld.so.conf.d/ 目录下的配置文件指定的动态库绝对路径（通过ldconfig生效，一般是非root用户时使用）；4、gcc默认动态库目录：/lib:/usr/lib:usr/lib64:/usr/local/lib等。# 默认的动态库搜索路径可以通过ld --verbose命令查看# 查看某个程序需要的动态链接库可通过 ldd 来实现l Gfortran编译器常用环境变量【必须了解的一点】在 GCC 4.0 之前，g77 是 GCC 的一部分；此后，gfortran 是 GCC 的一部分。g95 是一个基于 GCC 的 Fortran 编译器，它不是 GCC 的一部分。 像 g++ 一样，gfortran 也只是设置过 Fortran 程序所需基本环境的 gcc 的一个前端。如下的Fortran例子我们可以通过下面 gcc 的命令来编译： 123$ gfortran helloworld.f -o helloworld# 等价于$ gcc helloworld.f -o helloworld -lgfortran -lgfortranbegin 注意： 库文件libgfortranbegin.a (通过命令行选项-lgfortranbegin被调用) 包含运行和终止一个 Fortran 程序所必须的开始和退出代码。库文件libgfortran.a 包含 Fortran 底层的输入输出等所需要的运行函数。当运行 gfortran 时，会自动链接这两个库 当我们运行 gfortran 时，实际上运行并不是这个编译器，而是编译器驱动器。该驱动器解析命令行中所给出的选项，然后才调用真正的编译器，汇编器和链接器。默认情况下，编译器驱动器根据命令行中给定的文件的后缀决定它自己下一步的动作：一个名为 foo.c 将传递给 C 编译器，而名为 foo.f95 的文件将传递给 Fortran 95 的编译器，等等。 理解了这一点，我们就可以知道gcc helloworld.f将自动调用 fortran 的编译器。只不过我们要为链接器指定必要的库。 理解了这一点，我们可以知道 gfortran helloworld.c 可以编译一个 c 程序，gfortran helloworld.cpp -lstdc++编译的是一个 C++ 程序。 综上： Gfortran所用的环境变量与gcc是一样的，其余不同的环境变量在以后遇到后再添加 参考： GCC相关的环境变量 LIBRARY_PATH和LD_LIBRARY_PATH环境变量的区别 Linux添加环境变量与GCC编译器添加INCLUDE与LIB环境变量 Linux gcc链接动态库出错：LIBRARY_PATH和LD_LIBRARY_PATH的区别 GUN GCC中文手册 GCC 参数详解 Fortran编译初步]]></content>
      <categories>
        <category>GCC</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Q&A-ubuntu]]></title>
    <url>%2F2017%2F03%2F04%2FQ-A-ubuntu%2F</url>
    <content type="text"><![CDATA[这篇文档主要记录一些在Ubuntu使用过程中遇到的问题，然后就是各种google后的解决方案～ 20170304 - Matlab中文显示乱码Q：在英文环境下安装的Matlab，打开包含有中文字符的文件时将乱码显示 A：由于linux下的Matlab是用Java编写的，因此切入点就是Java的中文显示 确定Matlab的JRE目录位置 /matlab/sys/java/jre/glnx86/jre 请根据自己的安装目录和版本确定JRE的目录； $ cd /(matlab 目录)/sys/java/jre/glnx86/jre/lib/fonts/； 建立目录fallback: $ mkdir fallback，可能需要超级用户权限执行 把字体复制或链接到fallback目录 linux下的系统字体位于/usr/share/fonts文件夹下，可将相应的中文字体复制到fallback文件夹下 sudo cp xxx.ttc path/to/matlab/fonts/fallback/ 进入fallback目录，执行 mkfontscale 命令； 将上一步生成的文件添加到 lib/fonts/fonts.dir文件中，可用以下命令完成，当然也可以用编辑器复制粘贴： 为了使fonts.dir可写，需要用chmod $ sudo chmod 766 fonts.dir $ cat fallback/fonts.scale &gt;&gt; fonts.dir (注意fonts.dir应该设为可写) 把fallback下的字体加上可读属性：$ chmod a+r fallback/* 至此Matlab的Java环境中文支持安装完了，接下来配置Matlab; 进入Matlab，选择 菜单 File&gt;&gt;Preferences&gt;&gt;Fonts ，text fonts去掉Use system default,选择文泉驿字体一种就行了； 如果没有相应的字体，请把fallback下的字体加上可读属性：$ chmod a+r fallback/* 另：文泉驿字体安装 123sudo apt-get install ttf-wqy-microhei #文泉驿-微米黑sudo apt-get install ttf-wqy-zenhei #文泉驿-正黑sudo apt-get install xfonts-wqy #文泉驿-点阵宋体 安装完成后可以去系统字体文件夹中的truetype文件夹中查找相应的ttc文件 参考： ubuntu 安装Matlab 解决显示中文乱码 ubuntu安装文泉驿字体（分别安装微米黑、正黑、点阵宋体） 20170304 - Gedit中文显示乱码Q：在windows下编写的文件放到Ubuntu中无法用gedit正确显示中文 A：主要还是编码的问题，增加gedit的编码方式 代码解决方式 1gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;[&apos;GB18030&apos;,&apos;UTF-8&apos;,&apos;CURRENT&apos;,&apos;ISO-8859-15&apos;,&apos;UTF-16&apos;]&quot; 图形界面解决方式 终端：dconf-editor 若是运行说找不到该命令，则需要安装运行sudo apt-get install dconf-tools 展开/org/gnome/gedit/preferences/encodings 在candidate-encodings中加入&#39;GB18030&#39;,&#39;UTF-8&#39;,&#39;CURRENT&#39;,&#39;ISO-8859-15&#39;,&#39;UTF-16&#39; 参考： Ubuntu16.04 gedit中文乱码 Gedit中文乱码 20170307 - Linux下应用程序的安装Q：Linux系统有许多程序不像windows中那样，双击运行就可以安装，需要自己输入命令执行安装过程 A：除了*.deb的安装包可以直接双击安装外，还要二进制形式的安装和源码形式的安装。 以二进制形式安装： 以二进制方式发布的程序，安装相对简单，一般只要解压缩后设置好环境变量即可，以Gaussian09为例： 将压缩包复制到某个地方，如/opt 解压缩：tar -xvf gaussian09.tar.gz 设置环境变量：修改~/.bashrc，添加： 12345##Add␣for␣g09export g09root=&quot;/opt&quot;export GAUSS_SCRDIR=&quot;/tmp&quot;. $g09root/g09/bsd/g09.profile##End␣for␣g09 刷新环境设置：. ˜/.bashrc或重新登录下。 以源码形式安装： 源代码发布的程序安装相对复杂，需了解所采用的编译环境，并对配置等做相应修改（主要修改编译命令、库、头文件等编译参数）: 查看主页等帮助 解压缩：tar -xvf appsrc.tar.gz 进入解压缩的目录查看是否有README、INSTALL和doc等类似文件和目录，有的话先查看 有configure文件的话，可以./confugure -h看看帮助及选项 生成配置：./confugure [OPTION]... [VAR=VALUE] 修改生成的Makefile等文件 编译：make 安装：make install 注意： 每种软件的具体安装步骤不一定相同，务必要看对应说明 一些在configure、Makefile中常见变量： 1234567891011121314--prefix：安装到的目录前缀CC：编译C源文件的编译器命令CLAGS：C程序编译参数CPP：预处理参数CXX：编译C++源文件的编译器命令CXXFLAGS：C++程序编译参数F77：编译Fortran77源文件的编译器命令F90：编译Fortran90及以后源文件的编译器命令FC：编译Fortran源文件的编译器命令FFLAGS：Fortran编译参数INCLUDE：头文件参数LIB：库文件参数LINK：链接参数OFLAG：优化参数 参考： 程序安装简介 20170307 - Linux Shell中的点命令与source命令Q：Linux中的点命令是什么，与source命令又是什么关系，它们与其他的可执行程序之间又是声明关系 A：点命令就是source命令，但是其与./cmd.sh不同 格式：source FileName source命令是bash中的内建命令，它等同于点命令（.），用于读取和在当前shell环境中执行FILENAME中的命令，执行完毕之后退出码为该文件中的最后一个命令的退出码。FILENAME可以没有执行权限。有时候我们修改了/etc/profile里面的内容，如增加了环境变量，那么要立即生效的话，就必须使用source命令或者点命令在当前shell中执行一下； 123# 以下命令等效source ~/.bashrc. ~/.bashrc 另： source还有另外一种格式：source filename [arguments] 作用： Read and execute commands from FILENAME and return. The pathnames in $PATH are used to find the directory containing FILENAME. If any ARGUMENTS are supplied, they become the positional parameters when FILENAME is executed.【目前只在intel编译器安装过程中看到过此命令格式】 比较： 1234567# a.sh#! /bin/basha=&quot;hi&quot;# 以下两个命令执行结果不同source a.sh &amp;&amp; echo $a./a.sh &amp;&amp; echo $a 用source命令执行，脚本中的命令是在本shell中读入然后执行的，因而执行echo命令时变量a是有值的； 直接执行脚本，会另起shell进程，而启动这个进行的时候，它会建立自己的进程环境，然后在这个进程结束的时候，它所建立的环境也随之被销毁。 在当前shell中执行和在子shell中执行的区别是，后者定义的变量和函数在执行结束后就消失了，而前者却可以保留下来。./xxx.sh和sh xxx.sh都是在当前shell的子shell中执行的，子shell中的变量不会影响父shell，而source是把文件中的命令都读出来一个个执行，所有的变量其实就是在父shell中设置的。 参考： 我使用过的Linux命令之source - 在当前shell环境中执行指定文件中的命令 [Linux] 关于点命令 LINUX Shell脚本中点号和source命令 source命令 20170313 - Markdown图片居中显示Q：如何实现Typora中图片在导出时的居中显示？ A： 在需要居中的图片上下添加如下代码 123&lt;div align=center&gt;![]()&lt;/div&gt; 修改CSS文件（暂时还没找到相应的解决方法） 20170327 - 远程服务器免密登录Q：对于需要频繁登录的Linux服务器，如何实现免密直接登录（类似于git中ssh的设置）？ A： 首选方法——ssh-copy-id 前提：确保本地Linux系统以及服务器上的Linux系统的个人home目录下有文件夹.ssh，如果不存在，需要分别在本地和服务器上运行以下命令 123456# -t 表示的是加密类型# rsa 表示加密方式，它也是默认的加密方式，因此可以省略，直接键入ssh-keygenssh-keygen -t rsa# 默认的RSA长度是2048位，我们可以加长，命令如下ssh-keygen -b 4096 -t rsa 注： 之后需要输入保存的路径，以及是否加密id_rsa文件，可以自定义，一般直接enter键到底即可，即保存在默认路径下，且不设置id_rsa文件的密码 更多的ssh-keygen 基本用法可以参见Here 采用ssh-copy-id将公钥上传到Linux服务器中 1ssh-copy-id username@remote-server 注： 之后需要输入一次远程服务器用户的登录密码 输入远程用户的密码后，SSH公钥就会自动上传了。SSH公钥保存在远程Linux服务器的.ssh/authorized_keys文件中。 如果需要将多台本地实现免密登录，只需重复该命令即可，其每运行一次，就会将相应的本地公钥id_rsa.pub复制到服务器的.ssh/authorized_keys文件中 上传完成后，SSH登录就不需要再次输入密码了．但是首次使用SSH Key登录时需要输入一次SSH密钥的加密密码．（只需要输入一次，将来会自动登录，不再需要输入密钥的密码．） 使用scp命令来传送文件时也不需要输入密码． 复制粘贴 1cat id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys 实际也可以直接采用复制本地公钥到服务器上的.ssh/authorized_keys文件来实现添加 alias 实现命令快速登陆 在home目录下的配置文件中（一般为.bashrc添加alias，实现简化登录 12345678# 打开配置文件vim ~/.bashrc# 添加如下语句alias to-101=&apos;ssh username@hostip&apos;# source. ~/.bashrc 之后就可以在终端中直接输入to-101实现快速登录 无法登录的一般原因 客户端的私钥和公钥文件位置必须位于 ~/.ssh 下。 确保双方 ~/.ssh 目录，父目录，公钥私钥，authorized_keys 文件的权限对当前用户至少要有执行权限，对其他用户最多只能有执行权限。 以我的设置为例，对~/.ssh/authorized_keys的权限是600 - **注意git登录，要求对公钥和私钥以及config文件，其他用户不能有任何权限。** 服务器端 ~/.ssh/authorized_keys 文件名确保没错 参考： SSH Key：两个简单步骤实现SSH无密码登录 Linux/UNIX下使用ssh-keygen设置SSH无密码登录 ssh public key认证免密码登录 20170519 - shell脚本中export变量生效 问题：在shell脚本中，若要使用export命令， 如果直接运行./abc.sh，之后使用echo命令查看相应变量还是处于未赋值状态 原因：参见该部分内容 [20170307 - Linux Shell中的点命令与source命令] 解决方法：使用source或是.命令]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fortran不tran]]></title>
    <url>%2F2017%2F03%2F04%2FFortran%E4%B8%8Dtran%2F</url>
    <content type="text"><![CDATA[20170303 - 命令行参数一般我们在编程的时候都会遇到如此情况：每次程序执行之后需要修改某些参数变量，然后再进行编译连接，如此往复。要是参数比较多的话，我们可以使用namelist来设置变量；但是要是参数不是很多，那么我们就可以通过Fortran中获取命令行参数的方法获得。 一般我们我们可以通过以下两种来实现获取命令行参数： GET_COMMAND_ARGUMENT(number [, value, length, status] ) 作用：获取命令行中的第number个参数的值 适用：Fortran 2003以及之后版本 参数： number：in，整型标量&gt;=0 value：out，optional，字符型标量 length：out，optional，整型标量 status：out，optional，整型标量 返回：调用子程序，然后 value参数保留第number个参数的值，若其不能容纳，则适当截断以适应value长度； 若命令行上指定参数个数小于number参数，则value被赋值为空白，若number=0，则返回程序名； length参数包含第number个参数的长度； 若参数获取失败，则status为正值；若value中的参数是被截断的，则status为-1；否则其为0。 拓展： GET_COMMAND([COMMAND, LENGTH, STATUS ])：获取整个命令行参数，详情 COMMAND_ARGUMENT_COUNT()：获取命令行参数个数，详情 GETARG(pos, value) 作用：得到命令行中第pos个参数，可以兼容fortran 77，建议使用第一种子函数获取参数 参数： pos：in，整型标量&gt;=0 value：out，字符型标量 返回：调用子程序，然后 value保留第pos个参数的值，若无法容纳，则需要截断，若pos参数大于实际命令行参数个数，则value赋值为空，若pos=0，则返回程序名 拓展： IARGC()：获取命令行参数个数，可兼容fortran 77，建议使用COMMAND_ARGUMENT_COUNT() 延伸：数据类型转换 由于通过以上子程序获得参数都是字符型数据，因而在需要使用整型或是实型时，就需要进行适当的数据类型转换。 我们可以利用Fortran内部文件实现数据类型转换。 彭国伦建议将内部文件（Internal File）称为“字符串变量文件”，这个叫法比较贴切。 我猜测Fortran中写入文本文件实际经过两个过程：首先将数据转换为字符类型，然后将字符符 号写入文件中。读文件则是先将文件中数据以字符类型读入，然后根据赋给的变量类型进行相应 类型转化。这样看的话，内部文件方法是将字符串变量看成一个“文件”，然后写操作将数据转化为字符类型，然后“写入”字符串变量这个“文件”中，从而间接实现类型转换。 12345!字符型转换为数值型，in-str；out-numericread(str, *) numeric!数值型转换为字符型，可以使用格式化控制字符串write(str, *) numeric，str-out；numeric-in 参考： The GNU Fortran Compiler Fortran接收命令行参数方法 20170304 - Fortran中的数组【了解】Fortran中的数组可以大致分为2类6种 显式数组 显式形状(Explicit-shape)数组：固定的秩、每一维的长度和形状，其中下界可以忽略，如下： INTEGER M(10,10,10),K(-3:6,4:13,0:9) 自动(Automatic)数组：一种特殊显形数组，只能是过程中的局部变量。 自动数组必须在过程中加以声明，并且它至少有一维的上下界是不定的表达式，通过整型变量或整型表达式求出 过程中其后的变量或表达式值的变化不会对数组的上下界产生影响 1234SUBROUTINE EXAMPLE(N,R1,R2)DIMENSION A(N,5),B(10*N)……N=IFIX(R1)+IFIX(R2) 理解：在子函数中声明数组，其中的某几维是变量 可调(Adjustable)数组：一种特殊显形数组，只能是过程中的一个哑元。 可调数组中至少有一维的上下界不是常数，这个维的上下界只有当过程被调用时才能最终确定。 该维的上下界表达式中的整型变量可以是通过过程传递的哑元，也可以是通过COMMON语句中传递的整型常量或变量。 12345678910111213141516171819DIMENSION A1(10,35),A2(3,56)……!实参中必须要有数组名SUM1=THE_SUM(A1,10,35)SUM2=THE_SUM(A2,3,56)END!过程中也要有数组名 FUNCTION THE_SUM(A,M,N) DIMENSION A(M,N)SUMX=0.0DO J=1,N DO I=1,M SUMX=SUMX+A(I,J) END DOEND DOTHE_SUM=SUMXEND FUNCTION 理解：参数传递需要包含数组名，可以通过这种方式改变数组内部数值，而自动数组是局部变量，过程内改变不会产生任何影响。 隐式数组 假定形状(Assumed-shape)数组：一种在过程中使用的特殊类型数组，这种数组是过程中的哑元，它从实际传递过来的数组获得形状参数。 假定形状数组的秩由冒号的个数决定。它的一般形式是：([下界]:[,[下界]:]…)。 如果不指定下界，则默认值为1。上界值＝过程调用时实参数组对应维的长度＋下界值－1。 注意它与可调数组的区别在于,可调数组属于显型数组（必须指定上界，尽管这个上界可以是变量或表达式）的范围，而假定形状数组的上界是不能指定的。 应用假定形状数组为哑元的过程时必须有显式的接口INTERFACE语句。 12345678INTERFACE SUBROUTINE SUB(M) INTEGER M(:,1:,5:) END SUBROUTINEEND INTERFACEINTEGER L(20,5:25,10)CALL SUB(L)! 在此例中数组M的维界是(1:20,1:21,5:14) 理解：与可调数组十分类似，但区别在于可调数组必须指定上界，但是假定形状数组不能指定上界，没有传递维度参数 假定大小(Assumed-size)数组：一种在过程中使用的特殊类型数组的哑元，这种数组是在过程中的哑元，它从实际传递过来的数组获得数组大小 除了最后一维的上界以外，其它所有特征（秩，长度和维界）都必须指定 声明一个假定大小数组时，最后一个的上界用星号*表示。它的一般形式是：([显型维界,][显型维界,]…[下界:],*)，其中数组A的最后一维没有必要成为完整的维。 假定大小数组的秩和形状可以和实际传入的数组不同，传入的数组只确定它的大小。实际数组的元素按列传递给假定大小数组，假定大小数组也按列接收。接受的过程中假定大小数组的最后一维的长度会改变来接受所有传递进来的数组元素，于是最终给出数组的大小。如上例子中的ASSUME子程序，如果以数组X为哑元来调用的话， 12345678910REAL X(7)CALL ASSUME(X)! 则数组X的元素与数组A的对应顺序是：X(1)：A(1,1,1)X(2)：A(2,1,1)X(3)：A(1,2,1)X(4)：A(2,2,1)X(5)：A(1,1,2)X(6)：A(2,1,2)X(7)：A(1,2,2) 延迟形状(Deferred-shape)数组：可分配数组必须以延迟形状的形式来声明。它每一维的长度只有在分配数组才被确定。声明迟形数组时，秩由冒号确定，但长度是未知的。 可分配数组可由下列方式声明：使用ALLOCATABLE语句、DIMENSION语句、TARGET语句或在类型声明中使用ALLOCATABLE属性。 如果迟形数组以DIMENSION语句或TARGET语句声明，则在其它语句中必须给出ALLOCATABLE属性。在迟形数组的大小、形状和维界没有确定之前，其任何部分都不能被引用，可分配数组的大小、形状和维界在ALLOCATE语句执行时才被确定。 123INTEGER,ALLOCATABLE:: A(:,:)REAL,ALLOCATABLE,TARGET:: B(:,:),C(:)ALLOCATE(A(2,3),C(5),B(SIZE(C),12)) 【掌握】Fortran中的动态数组：Fortran90中有三种动态数组。这三种动态数组允许在运行时创建，数组大小由计算或输 入得到的值决定。 自动数组 &amp;&amp; 可调数组【不建议使用】 这需要用到过程的概念和良好的程序设计结构。如果碰到有些数组需要作为全局变量在不同的过程中进行处理的情况，就只好采用开一个大数组的办法来解决。 可分配数组【推荐】 一个可分配数组使用ALLOCATABLE显式声明，用 ALLOCATAE语句显式分配，用DEALLOCATE语句显式销毁或当其为未指定SAVE属性的局部数组时，退出程序时自动销毁。一个全局可分配数组一直存在直到显式销毁（deallocate语 句可能与allocate语句不在同一个程序中）。 一个可分配数组可以是一个程序局部变 量，也可以放在模块变量中，对模块中所有程序来说是全局的。 如果数组大小取决于一个计算的值，而不是 哑元或模块变量、common或主程序，使用可分配数组。可用ALLOCATED内置函数测试一个 可分配数组的分配状态。 123456789101112131415161718subroutine Peachuse Recipe ! Accesses global allocatable array, Jam. real, allocatable :: Pie(:,:) ! Pie is a 2-dimensional allocatable array.... allocate ( Pie(N,2*N ) ) ! Allocate a local allocatable array. if (.not.allocated(Jam)) allocate ( Jam(4*M) ) ! Allocate a global allocable array if ! it is not already allocated. ... deallocate ( Pie ) ...end subroutine Peachmodule Recipe ! Jam is a global allocatable array, and real, allocatable :: Jam(:) ! can be allocated and deallocated in ... ! any procedure(s) using this module.end module Recipe 指针数组 指针数组类似于可分配数组，他们用ALLOCATE语句显式分配，拥有任意计算大小并且用 DEALLOCATE语句显式销毁。 另： 过程：过程是在程序的执行中可被直接调用的、封装在一起的、进行计算或处理的语句序列。它是任何一种过程型程序设计语言的重要组成部分，对Fortran语言也不例外。F90中，一个过程的定义就是指它是一个函数或是一个子程序。 哑元：通常过程是带有参数的，在Fortran中把参数称为变元（实元或哑元），过程定义中的变元是哑元，过程引用中的变元是实元。在调用过程时，要用实元代替哑元，这就是哑实结合。（类似C中的虚变量） *.mod文件通常是使用了 module 的源代码经过编译后产生的，用于标记该模块的接口。你可以认为是头文件，只不过是自动生成的头文件。其实现为.o文件 参考： Dynamic Arrays Fortran中动态数组 5.1.2 数组类型]]></content>
      <categories>
        <category>fortran</category>
      </categories>
      <tags>
        <tag>fortran</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sz实例简析]]></title>
    <url>%2F2017%2F03%2F03%2Fsz%E5%AE%9E%E4%BE%8B%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[这篇文档主要对sz的example中的4个源代码进行简要分析学习，这里包括C接口的testdouble_compress.c和testdouble_decompress.c，以及Fortran接口的testdouble_compress.f90和testdouble_decompress.f90。 C 接口实例压缩实例分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * @file test_compress.c * @author Sheng Di * @date April, 2015 * @brief This is an example of using compression interface * (C) 2015 by Mathematics and Computer Science (MCS), Argonne National Laboratory. * See COPYRIGHT in top-level directory. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//sz所需的头文件 #include "sz.h"#include "rw.h"//此部分内容用于计算time cost，可忽略struct timeval startTime;struct timeval endTime; /* Start and end times */struct timeval costStart; /*only used for recording the cost*/double totalCost = 0;void cost_start()&#123; gettimeofday(&amp;costStart, NULL);&#125;void cost_end()&#123; double elapsed; struct timeval costEnd; gettimeofday(&amp;costEnd, NULL); elapsed = ((costEnd.tv_sec*1000000+costEnd.tv_usec)-(costStart.tv_sec*1000000+costStart.tv_usec))/1000000.0; totalCost += elapsed;&#125;//此部分为主程序int main(int argc, char * argv[])&#123; //最高支持5维，不赋值默认为0 int r5=0,r4=0,r3=0,r2=0,r1=0; //相关的文件路径，依次为：null，原始数据文件，压缩后数据文件 char outDir[640], oriFilePath[640], outputFilePath[640]; //sz配置文件 char *cfgFile; //读取参数，main参数传递，参数个数少于3个报错 if(argc &lt; 3) &#123; printf("Test case: testdouble_compress [config_file] [srcFilePath] [dimension sizes...]\n"); printf("Example: testdouble_compress sz.config testdouble_8_8_128.dat 8 8 128\n"); exit(0); &#125; //指定配置文件 cfgFile=argv[1]; //格式化写入某个字符串，其原型： // int sprintf( char *buffer, const char *format, [ argument] … ); sprintf(oriFilePath, "%s", argv[2]); //atoi() 函数用来将字符串转换成整数(int)，其原型为： // int atoi (const char * str); if(argc&gt;=4) r1 = atoi(argv[3]); //8 if(argc&gt;=5) r2 = atoi(argv[4]); //8 if(argc&gt;=6) r3 = atoi(argv[5]); //128 if(argc&gt;=7) r4 = atoi(argv[6]); if(argc&gt;=8) r5 = atoi(argv[7]); printf("cfgFile=%s\n", cfgFile); //压缩初始化 int status = SZ_Init(cfgFile); //确定输出文件名 sprintf(outputFilePath, "%s.sz", oriFilePath); //元素个数，out int nbEle; //将原多维数据文件读入内存中，同时将其一维化，实质是一维数组形式，具体的函数定义可看sz/src/rw.c文件 double *data = readDoubleData(oriFilePath, &amp;nbEle, &amp;status); if(status!=SZ_SCES) &#123; printf("Error: file %s cannot be read!\n", oriFilePath); exit(0); &#125; //压缩后文件的大小，out int outSize; //计时开始 cost_start(); //压缩开始， unsigned char *bytes = SZ_compress(SZ_DOUBLE, data, &amp;outSize, r5, r4, r3, r2, r1); //another compression method /*char *bytes = (char *)malloc(nbEle*sizeof(double)); // char* bytes = SZ_compress_args(SZ_DOUBLE, data, &amp;outSize, ABS, 1E-12, 0.000001, r5, r4, r3, r2, r1);*/ //计时结束 cost_end(); printf("timecost=%f\n",totalCost); //降压缩后的字节数据存入文件 writeByteData(bytes, outSize, outputFilePath, &amp;status); if(status!=SZ_SCES) &#123; printf("Error: file %s cannot be written!\n", outputFilePath); free(data); exit(0); &#125; //释放资源 free(data); free(bytes); printf("done\n"); //压缩结束 SZ_Finalize(); return 0;&#125; 解压缩实例分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171/** * @file test_decompress.c * @author Sheng Di * @date April, 2015 * @brief This is an example of using Decompression interface. * (C) 2015 by Mathematics and Computer Science (MCS), Argonne National Laboratory. * See COPYRIGHT in top-level directory. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;//sz所需要的头文件#include "sz.h"#include "rw.h"//此部分内容用于计算time cost，可忽略struct timeval startTime;struct timeval endTime; /* Start and end times */struct timeval costStart; /*only used for recording the cost*/double totalCost = 0;void cost_start()&#123; gettimeofday(&amp;costStart, NULL);&#125;void cost_end()&#123; double elapsed; struct timeval costEnd; gettimeofday(&amp;costEnd, NULL); elapsed = ((costEnd.tv_sec*1000000+costEnd.tv_usec)-(costStart.tv_sec*1000000+costStart.tv_usec))/1000000.0; totalCost += elapsed;&#125;//此部分为主程序int main(int argc, char * argv[])&#123; //同上 int r5=0,r4=0,r3=0,r2=0,r1=0; //表示：未压缩前的数据个数（r1×r2×...)， int nbEle, totalNbEle; //表示：压缩数据文件路径，解压缩后的文件路径 char zipFilePath[640], outputFilePath[640]; //同上 char *cfgFile; //同上 if(argc &lt; 2) &#123; printf("Test case: testdouble_decompress [configFile] [srcFilePath] [dimension sizes...]\n"); printf("Example: testdouble_decompress sz.config testdouble_8_8_128.dat.sz 8 8 128\n"); exit(0); &#125; //同上 cfgFile = argv[1]; sprintf(zipFilePath, "%s", argv[2]); if(argc&gt;=4) r1 = atoi(argv[3]); //8 if(argc&gt;=5) r2 = atoi(argv[4]); //8 if(argc&gt;=6) r3 = atoi(argv[5]); //128 if(argc&gt;=7) r4 = atoi(argv[6]); if(argc&gt;=8) r5 = atoi(argv[7]); //确定未压缩前的元素个数 if(r2==0) nbEle = r1; else if(r3==0) nbEle = r1*r2; else if(r4==0) nbEle = r1*r2*r3; else if(r5==0) nbEle = r1*r2*r3*r4; else nbEle = r1*r2*r3*r4*r5; //同上 sprintf(outputFilePath, "%s.out", zipFilePath); //表示：压缩后的数据大小（字节计），程序执行状态，out int byteLength, status; unsigned char *bytes = readByteData(zipFilePath, &amp;byteLength, &amp;status); if(status!=SZ_SCES) &#123; printf("Error: %s cannot be READ!\n", zipFilePath); exit(0); &#125; //同上 cost_start(); //解压缩，全部为in double *data = SZ_decompress(SZ_DOUBLE, bytes, byteLength, r5, r4, r3, r2, r1); //同上 cost_end(); printf("timecost=%f\n",totalCost); free(bytes); //int i=0; //for(;i&lt;8192;i++) // printf("i=%d, data=%f\n",i,data[i]); //将解压后的数据（一维数据）写入文件 writeDoubleData_inBytes(data, nbEle, outputFilePath, &amp;status); if(status!=SZ_SCES) &#123; printf("Error: %s cannot be written!\n", outputFilePath); exit(0); &#125; printf("done\n"); //SZ_Finalize(); //以下用于与原数据对比，判断两者的差异程度 char oriFilePath[640]; strncpy(oriFilePath, zipFilePath, (unsigned)strlen(zipFilePath)-3); oriFilePath[strlen(zipFilePath)-3] = '\0'; double *ori_data = readDoubleData(oriFilePath, &amp;totalNbEle, &amp;status); if(status!=SZ_SCES) &#123; printf("Error: %s cannot be read!\n", oriFilePath); exit(0); &#125; int i; double Max, Min, diffMax, err, maxpw_relerr = 0, relerr; Max = ori_data[0]; Min = ori_data[0]; diffMax = fabs(data[0] - ori_data[0]); for (i = 0; i &lt; nbEle; i++) &#123; if (Max &lt; ori_data[i]) Max = ori_data[i]; if (Min &gt; ori_data[i]) Min = ori_data[i]; err = fabs(data[i] - ori_data[i]); if (diffMax &lt; err) diffMax = err; if(ori_data[i]!=0) &#123; relerr = err/fabs(ori_data[i]); /*if(relerr&gt;0.00001) &#123; printf("error:i=%d, ori_data=%f, dec_data=%f\n",i, ori_data[i], data[i]); exit(0); &#125;*/ if(maxpw_relerr&lt;relerr) maxpw_relerr = relerr; &#125; /*if(fabs(data[i] - ori_data[i]) &gt; 1E-1) &#123; printf("error: i=%d, %.20G, %.20G\n",i,ori_data[i], data[i]); exit(0); &#125;*/ &#125; printf ("Max absolute error = %.20G\n", diffMax); printf ("Max relative error = %.20G\n", diffMax/(Max-Min)); printf ("Max pw_relative err = %.20G\n", maxpw_relerr); free(ori_data); free(data); return 0;&#125; Fortran 接口实例压缩实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546program p ! 使用sz模块 use sz use rw implicit none ! arg：配置文件参数 character(len=32) :: arg ! allocatable：动态分配数组 real(kind=8), dimension(:,:,:), allocatable :: grid integer(kind=4) :: gridsize1,gridsize2,gridsize3 real(kind=8) :: res=0 integer :: i,j,k integer(kind=4) :: ierr, outSize ! the size of the compressed stream INTEGER(kind=1), DIMENSION(:), allocatable :: Bytes gridsize1 = 10 gridsize2 = 10 gridsize3 = 10 write (6,*) &apos;start....&apos; allocate(grid(gridsize1,gridsize2,gridsize3)) DO i=1,gridsize1 DO j=1,gridsize2 DO k=1,gridsize3 grid(i,j,k)=i+j+k END DO END DO END DO call getarg(1, arg) call SZ_Init(arg,ierr) call SZ_Compress(grid, Bytes, outSize) call writeData(Bytes, outSize, &apos;test_f.sz&apos;) ! Free memory deallocate(grid) deallocate(Bytes) call SZ_Finalize() write (6,*) &apos;done.&apos;end program p 解压缩实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950program p !同上 use sz use rw implicit none ! 配置文件 character(len=32) :: arg ! 压缩后的数据流 integer(kind=1), dimension(:), allocatable :: bytes ! 网格大小 real(kind=8), dimension(:,:,:), allocatable :: grid integer(kind=4) :: gridsize1,gridsize2,gridsize3 real(kind=8) :: res=0 integer :: i,j,k integer(kind=4) :: ierr ! the size of the compressed stream integer(kind=4) :: outSize gridsize1 = 10 gridsize2 = 10 gridsize3 = 10 write (6,*) &apos;start....&apos; call getarg(1, arg) call SZ_Init(arg,ierr) ! 读入压缩数据，后两个参数都是out call readData(&apos;test_f.sz&apos;, bytes, outSize) ! 解压缩数据，（in，out，in，in，in） call SZ_Decompress(bytes, grid, gridsize1, gridsize2, gridsize3) ! 写入文件，从中可以看出out的grid数组是多维的 open(unit=10,file=&apos;test_f.txt&apos;) DO i=1,gridsize3 DO j=1,gridsize2 DO k=1,gridsize1 write (10,*) grid(k,j,i) END DO END DO END DO deallocate(grid) deallocate(bytes) write (6,*) &apos;done.&apos; call SZ_Finalize()end program p 参考： [SZ_packages]/example/…]]></content>
      <categories>
        <category>data compress</category>
      </categories>
      <tags>
        <tag>sz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文档分类快链]]></title>
    <url>%2F2017%2F03%2F02%2F%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB%E5%BF%AB%E9%93%BE%2F</url>
    <content type="text"><![CDATA[【不定期更新】各类文档的归类与快速链接。 JPEG JPEG函数库使用指南：主要对JPEG函数库的大致学习 JPEG配置安装官方指南：主要对JPEG的安装进行介绍 JPEG实例简析：主要对源代码中的示例程序进行大致学习 Utilities of JPEG：主要对JPEG的几个应用程序进行介绍 MIC MIC Hello world：主要对目前的MIC高性能技术进行一个大致介绍 MIC-基本语法：主要对MIC的offload模式以及相应的语法规则进行一个大致的学习 C/C++ C/C++中堆与栈简析 C/C++预处理命令 C/C++文件读写 string类字符访问方法 C海拾贝：主要记录一些比较好的C/C++用法 SZ Guide to sz：主要度sz压缩算法进行一个大致学习 sz配置文件详解：主要是对sz.config文件中的相关参数进行一个大致学习 sz实例简析：主要对example中的压缩与解压缩程序进行一个大致学习 GUN编译器 Linux环境变量及编译器库路径：主要对Linux环境变量做一个简单总结外加编译器的各种路径设置 Linux编译器学习：主要对gcc，g++以及gfortran的使用以及动态和静态库的生成进行大致学习 Linux中的函数库：主要对Linux静态和动态函数库进行一些内容的补充 C&amp;Fortran混合编程 ​ ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[sz配置文件详解]]></title>
    <url>%2F2017%2F03%2F02%2Fsz%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这篇文档内容主要是对sz的配置文件sz.config中的参数进行一个较为详细的介绍，原配置文件可在[sz_package]/example/sz.config中找到 ENVEndian Type：大端字节序（BIG_ENDIAN_DATA） or 小端字节序（LITTLE_ENDIAN_DATA） 一般来说，不同的机器Unicode编码方式不同： x86，x64和arm架构的机器：采用小端编码方式 PowerPc（ppc），MAC OS和KEIL C51：采用大端编码方式 Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。 如果一个文本文件的头两个字节（以十六进制形式表示）是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。 一般声明方式如下： 1dataEndianType = LITTLE_ENDIAN_DATA PARAMETERlayers在数据预测编码中的层数，可以取1,2,3，不过作者建议取1，这在大部分情况下都是适用的。 一般声明方式如下： 1layers = 1 sampleDistance采样距离决定了用于优化量化间隔的采样点数，例如，采样距离为50意味着2%的数据点是采样点。 一般声明方式如下： 1sampleDistance = 100 quantization intervals量化间隔必须设置为偶数，如果我们将其数值置为0，那么SZ将会自定搜寻最好的参数设置。如果不设置为0，那么它的取值范围为4~65536。 一般声明方式如下： 1quantization_intervals = 0 maximum quantization intervals注意：只有当量化间隔设置为0时，此项设置才是有效的。 一般而言，此项设置不会改变压缩率，但是会对压缩速度产生一定影响（通常只有10%的影响）。最大量化间隔数值设置越大，压缩速度越低，但是sz就越有能力实现高精度数据的高压缩率。 对于低精度数据的压缩（如压缩误差范围（error bound）为1e-2），最大量化间隔可以设置为256或是65536； 对于高精度数据的压缩要求（如压缩误差范围为1e-6），最大量化间隔可以设置为2097152(2^21）。 一般声明方式如下： 1max_quant_intervals = 2097152 predThreshold预测数据的百分比阈值。如predThreshold=0.97表示97%的数据将要被预测。 一般声明方式如下： 1predThreshold = 0.99 offset这个参数可以被用来调整不意压缩的数据的压缩率。数值范围为[0,10]，不过作者建议取0。 一般声明方式如下： 1offset = 0 SZ_Mode有3种模式可选： SZ_BEST_SPEED：sz将通过忽略Gzip压缩这一步来实现尽可能快的数据压缩； SZ_DEFAULT_COMPRESSION：sz将会在压缩率和压缩速度之间寻找一个平衡点，实现兼顾两方面的压缩； SZ_BEST_COMPRESSION：sz将尽量实现高压缩率 通常来说，模式1比其他两种模式的压缩速度要快（30%以上）。模式2的压缩率与模式3的压缩率接近（实际应该还是3的压缩率高一点），但是模式2的压缩速度较模式3要快10%左右。 一般声明方式如下： 1szMode = SZ_BEST_COMPRESSION GZIP_Mode注意：只用当szMode设置为SZ_BEST_COMPRESSION时，此项设置才是有效的。 有4种模式可供选择（各选项含义同上）： Gzip_NO_COMPRESSION Gzip_BEST_SPEED Gzip_BEST_COMPRESSION Gzip_DEFAULT_COMPRESSION 一般声明方式如下： 1gzipMode = Gzip_BEST_COMPRESSION errorBoundMode误差限定模式有5种可选：ABS_AND_REL, ABS_OR_REL, ABS, REL, PW_REL 一般声明方式如下： 1errorBoundMode = REL 同时，我们在选择了某种误差模式后，我们需要对其误差进行相应的数值限定： ABS 注意：只有当误差限定模式设置为ABS或是ABS_AND_REL, ABS_OR_REL时，此项设置才有效。 绝对误差限定压缩或是解压缩的数据误差在一个绝对误差范围内。例如，绝对误差值为0.0001意味着解压缩的数据数值必须在[ V-0.0001, V+0.0001 ]范围内，其中V是某个原始数据数值。 一般声明方式如下： 1absErrBound = 1E-2 REL 注意：只有当误差限定模式设置为REL或是ABS_AND_REL, ABS_OR_REL时，此项设置才有效。 相对误差限定压缩或是解压缩的数据误差在一个全局数据误差范围内。例如，相对误差值为0.01，数据集为{100,101,102,…,109,110}，那么全局数据变化范围为110-100=10，所以全局数据误差范围为10*0.01=0.1 一般声明方式如下： 1relBoundRatio = 1E-4 PW_REL 注意：只有当误差限定模式设置为PW_REL时，此项设置才有效。 一般不会使用这项误差模式，其含义如下： 123456789#point-wise relative Bound Ratio#pw_relBountRatio is to limit the (de)compression errors by considering the point-wise original data values.#For example, suppose pw_relBoundRatio is set to 0.01, and the data set is &#123;100,101,102,103,104,...,110&#125;, so the compression errors will be limited to &#123;1,1.01,1.02,....1.10&#125; for the data points.#Only valid when errorBoundMode = PW_RELpw_relBoundRatio = 1E-5#point-wise relative-error-bound segment size#The larger this value, the lower overhead of maitaining error bound information for each segment, while stricter absolute bound used to control the point-wise relative-error-bound.segment_size = 32 一般声明方式如下： 12pw_relBoundRatio = 1E-5segment_size = 32 ​ 参考 [sz_package]/example/sz.config]]></content>
      <categories>
        <category>data compress</category>
      </categories>
      <tags>
        <tag>sz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guide to Sz]]></title>
    <url>%2F2017%2F03%2F02%2FGuide-to-Sz%2F</url>
    <content type="text"><![CDATA[这篇文档内容主要对sz数据压缩函数库进行一个简单的介绍，同时对相关的函数接口也做一定的介绍。 [TOC] sz 是什么sz，全称为Squeeze，是一种以误差限定方式（error-bounded）来进行数据压缩的方法。它可以大幅度降低数据的存储量，同时保证解压后的数据与原数据误差在我们限定的范围内。 sz可以被用来压缩不同类型的数据（主要针对的是单精度和双精度型数据），并且适用于高维数组（目前最高支持维度为5维）； sz十分易于使用，它提供了三种编程语言的接口：Fortran，C，以及Java（Java版本在最近的几个高版本中没有继续更新）； sz支持不同架构的处理器，包括x86_32位，x86_64位，ARM，SOLARIS，以及IBM BlueGene 系列。 sz支持通过设定不同的误差方式来压缩数据，我们可以在sz.config中写明或是通过函数接口传入相关参数，关于误差方式这一部分可以参见sz配置文件详解； 如果我们有许多变量需要压缩，我们可以采用（作者推荐采用）批压缩方式； 这是作者个人主页 如何安装SZ首先，我们可以从这个页面下载到sz的源码，作者一直在更新当中。 执行安装步骤如下： 123configure --prefix=[INSTALL_DIR]makemake install 我们可以在[INSTALL_DIR]中找到相关的头文件include/以及链接库lib/，我们可以将其加入到相关路劲中，如C_INCLUDE_PATH，至于链接库，可以在编译的时候直接指定。 注意：在MAC OS上直接按照上述步骤安装会报错，解决方法是通过homebrew安装一个gcc，然后利用这个gcc来进行编译。原因在与MAC自带的gcc实质调用的是clang编译器，而非真正的gcc编译器。 快速上手我们可以在[sz_package]/example/中找到相关测试用例，若只想测试是否安装成功，可以直接运行test.sh这一脚本。 压缩实现命令格式 123456789# 基本命令格式：# ./cmd [sz config file] [data] [r1] [r2] [r3] ...# 3d数据./testdouble_compress sz.config testdouble_8_8_128.dat 8 8 128# 4d数据./testdouble_compress sz.config testdouble_8_8_8_128.dat 8 8 8 128./testfloat_compress sz.config testfloat_8_8_128.dat 8 8 128 解压缩实现命令格式 123456789# 基本命令格式：# ./cmd [sz config file] [data] [r1] [r2] [r3] ...# 3d./testdouble_decompress sz.config testdouble_8_8_128.dat.sz 8 8 128# 4d./testdouble_decompress sz.config testdouble_8_8_8_128.dat.sz 8 8 8 128./testfloat_decompress sz.config testfloat_8_8_128.dat.sz 8 8 128 在解压缩过程中，我们不需要提供误差限定信息，因为这些信息已经包含在了解压缩数据流中了。 API接口sz提供两种应用程序接口——C和Fortran（在SZ-0.x版本中还提供了Java接口）。这些接口在不同编程语言中是相近的，但是也存在一些不同，如在C中，我们需要声明数据类型（SZ_FLOAT或是SZ_DOUBLE），但是在Fortran接口中不需要这个参数。 关键的三个接口： SZ_Init()：初始化压缩或是解压缩 SZ_compress()/SZ_decompress()：压缩数据或是解压缩数据 SZ_Finalize()：结束压缩 C压缩与解压缩接口 SZ_Init and SZ_Init_Params 作用：初始化压缩。在对多个变量进行压缩过程中，SZ_Init()只需被调用一次。 原型：void SZ_Init(char *configFilePath); 参数： configFilePath：配置文件路径，一般我们都是直接将配置文件与程序放在同一文件夹下，进而路径只需要填写配置文件的文件名即可(such as example/sz.config) 返回：none 12345678910111213141516171819202122/* 另一个用于初始化的函数，但是不常用 */Synopsis: void SZ_Init_Params(sz_params * params);Input: params the configuration variable that contains the initialization information.Return: none.zz_params data structure:typedef struct sz_params&#123;unsigned int quantization_intervals; //default value: 0int dataEndianType; //what is the endian type of the original data set?int sysEndianType; //sysEndianType can be ignored, because it can bedetected autumnally by our compressor based on the system architectures.int sol_ID; //default value: #define SZ 101int layers; //default value: 1int sampleDistance; //default value: 50float preThreshold; //default value: 0.97int offset; //default value: 0int szMode; //default value: #define SZ_BEST_COMPRESSION 1int gzipMode; //default value: Gzip_BEST_SPEEDint errorBoundMode; //4 options: ABS, REL, ABS_AND_REL, ABS_OR_RELdouble absErrBound; //example: 0.0001double relBoundRatio; //example: 0.001&#125; sz_params; SZ_compress 作用：用于压缩浮点数数组。我们可以采用两类压缩接口（3种函数接口）来实现数据压缩。 原型： 1234567// 第一类第一种 char *SZ_compress(int dataType, void *data, int *outSize, int r5, int r4, int r3, int r2,int r1);// 第二类第一种char *SZ_compress_args(int dataType, void *data, int *outSize,int errBoundMode, double absErrBound, double relBoundRatio,int r5, int r4, int r3, int r2, int r1);// 第二类第二种int SZ_compress_args2(int dataType, void data, char compressed_bytes,int *outSize,int errBoundMode, double absErrBound, double relBoundRatio,int r5, int r4, int r3, int r2, int r1); 参数： datatype：数据类型，有两种选择SZ_FLOAT或是SZ_DOUBLE data：将要被压缩的数组指针，从原型中可以看出，数组指针为一维指针，因而我们只能将一维数组传递过去。在testdouble_compress.c中，程序先是从二进制文件中读取数据，然后讲相关数据指针传递给data，但是在实际编程过程中，我们可以直接将内存中的一维数组指针传给data，不需要额外进行转换（作者转换的原因是考虑到了不同机器编码方式不同） compressed_bytes：用于存放压缩后数据的内存空间 outSize：压缩后数据流的大小（单位为字节） r[1-5]：分别对应[1-5]维的维度，若是维数不到5维，则不到的维度数值为0 返回：压缩数据流（以字节计） SZ_decompress 作用：解压缩数据，我们可以有两类接口用于解压 原型： 1234//第一类void *SZ_decompress(int dataType, char *bytes, int byteLength,int r5, int r4, int r3, int r2, int r1);//第二类int SZ_decompress_args(int dataType, char *bytes, int byteLength,void* decompressed_array,int r5, int r4, int r3, int r2, int r1); 参数： datatype：同上 bytes：将要被解压的压缩数据流 byteLength：压缩数据流的长度 decompressed_array：用于存储被解压后的数据地址 r[1-5]：同上 返回：解压后的数据流 SZ_batchAddVar 作用：将某一变量以批处理的方式和其他变量一起进行压缩 原型： 1void SZ_batchAddVar(char* varName, int dataType, void* var,int r5, int r4, int r3, int r2, int r1,int errBoundMode, double absErrBound, double relBoundRatio); SZ_batchDelVar 作用：将某一个变量从要压缩列表中删除 原型： 1int SZ_batchDelVar(char* varName); 参数： varName：不进行批压缩的变量 返回：0-成功；1-没用找到相应的变量 SZ_batch_compress 作用：以批处理的方式压缩数据，所有声明要批处理压缩的数据会一起进行压缩（好处是提高了压缩率） 原型： 1char* SZ_batch_compress(int *outSize); 参数： outSize：压缩后的数据流（以字节计） 返回：压缩后的数据流 SZ_batch_decompress 作用：解压缩进行批压缩的数据流 原型： 1SZ_VarSet* SZ_batch_decompress (char* compressedStream,int compressedLength); 参数： compressedStream：被批压缩的数据流 compressedLength：被批压缩的数据流的长度（以字节计） 返回：包含有多个变量的解压缩后的数据结构体，可以参见VarSet.h查看更多细节。全局的SZ_VarSet定义在sz.h中。 SZ_Finalize 作用：释放内存以及结束压缩环境 原型：int SZ_Finalize(); 参数：none 返回：none Fortran压缩与解压缩接口 SZ_Init 作用：同 C 原型：SZ_Init(configFilePath, ierr); 参数： configFilePath：in，配置文件路径，定义方式为：CHARACTER(len=32) :: configFilePath ierr：out，成功返回0，失败返回1，定义方式为：INTEGER(Kind=4) :: ierr SZ_Compress 作用：同 C 原型： SZ_compress(data, bytes, outSize); 参数： data：in，将要被压缩的数组数据，定义方式为：REAL(KIND=8), DIMENSION(:,:,:) ::data bytes：out，压缩之后的字节流，定义方式为：INTEGER(kind=1), DIMENSION(:), allocatable :: bytes outsize：out，字节流大小（以字节计），定义方式为：INTEGER(kind=4) :: OutSize SZ_Compress (data, bytes, outSize,errBoundMode, absErrBound, relBoundRatio); 参数： errBoundMode：in，误差限定模式，可以取值为：ABS, REL, ABS_AND_REL, ABS_OR_REL，定义方式为：INTEGER(kind=4) :: ErrBoundMode absErrBound：in，绝对误差数值，定义方式为：REAL(kind=4 or 8) :: absErrBound relBoundRatio：in，相对误差数值，定义方式为：REAL(kind=4 or 8) :: relBoundRatio，关于误差限定的详细内容可以参见上面 SZ_Decompress 作用：同 C 原型：SZ_Decompress(bytes, data, [r1,r2,…]) 参数： bytes：in，要被解压缩的压缩数据流，定义方式为：INTEGER(kind=1), DIMENSION(:) :: Bytes data：out，解压后的数据，定义方式为：REAL(KIND=4 or 8), DIMENSION(:,:,…:,:), allocatable :: data r[1-5]：in，分别对应[1-5]维的数据维度，若维数不到5维，则不到的维度赋值为0，定义方式：INTEGER(kind=4) :: r1[, r2, r3, r4, r5]，也可以在接口中不填入没有数值的维度，如3维只填3个维度数值 SZ_BatchAddVar 作用：同 C 原型：void SZ_batchAddVar(varName, var,errBoundMode, absErrBound, relBoundRatio); 参数： varName：in，将要进行批处理压缩的变量的名字，定义方式为：CHARACTER(len=128) :: varName var：in，将要进行批处理压缩的变量 errBoundMode：in，误差限定模式，可选：ABS, REL, ABS_AND_REL, ABS_OR_REL，定义方式为：INTEGER(kind=4) :: ErrBoundMode absErrBound：in，绝对误差数值，定义方式为：REAL(kind=4 or 8) :: absErrBound relBoundRatio：in，相对误差数值，定义方式为：`REAL(kind=4 or 8) :: relBoundRatio SZ_BatchDelVar 作用：同 C 原型：void SZ_batchDelVar(varName, ierr); 参数： varName：in，将要被删除的变量名，定义方式：CHARACTER(len=128) :: varName ierr：out，成功返回0，没有找到相应变量返回1，定义方式：INTEGER(kind=4) :: ierr SZ_Batch_Compress 作用：同 C 原型：void SZ_Batch_Compress(bytes, outSize) 参数： bytes：out，压缩后产生的数据流，定义方式为：INTEGER(kind=1), DIMENSION(:), allocatable :: bytes outsize：out，压缩后数据流的大小（以字节计），定义方式为：INTEGER(kind=4) :: OutSize SZ_Batch_Decompress 作用：同 C 原型：void SZ_Batch_Decompress(bytes, outSize) 参数： bytes：in，将要被解压缩的数据流，定义方式为：INTEGER(kind=1), DIMENSION(:) :: Bytes outsize：in，解压后数据流大小，定义方式为：INTEGER(kind=4) :: OutSize SZ_Finalize 作用：同 C 原型：SZ_Finalize(); 参数：none 返回：none 参考： [SZ_package]/doc/sz-1.4-user-guide.pdf]]></content>
      <categories>
        <category>data compress</category>
      </categories>
      <tags>
        <tag>sz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu倒腾记～]]></title>
    <url>%2F2017%2F02%2F24%2FUbuntu%E5%80%92%E8%85%BE%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[零、安装后必做 本次安装系统Ubuntu-Kylin 16.04版 更新软件源，采用科大软件源 更新系统及其他组组件 更新设置中的language，进而可以进行中文输入 设置桌面菜单左移，命令如下 1gsettings set com.canonical.Unity.Launcher launcher-position Left ​ 一、系统软件1. 输入法自带的就行，sogou不是很好用，Kylin自带了多种输入法，包括sogou，google以及小企鹅等 2. git安装git，并克隆仓库 123456789101112# installsudo apt-get install git# Git ssh keygit config --global user.name &quot;test&quot;git config --global user.email &quot;test@gmail.com&quot;cd ~/.ssh #orssh-keygen -t rsa -C “test@gmail.com”# Git clonegit clone git@github.com:yourname/yours.git 3. 安装VIM1sudo apt-get install vim 4. 安装Curlsudo即可 5. VirtualBox虚拟机安装主要是用于运行win10环境进行写文档 6. Shodowsocks123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 参考:Here 7. Pip1sudo apt-get install python3-pip python-dev build-essential 参考：Here 二、编辑软件1. Typora按照以下命令行进行安装 123456789# optional, but recommendedsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE# add Typora&apos;s repositorysudo add-apt-repository &apos;deb https://typora.io ./linux/&apos;sudo apt-get update# install typorasudo apt-get install typora 2. Leanote官网下载安装包，解压即可使用 3. 为知笔记按照以下命令行进行安装 123$ sudo add-apt-repository ppa:wiznote-team #添加官方源$ sudo apt-get update #更新源$ sudo apt-get install wiznote #安装为知笔记 4. Lyx主要用于编写Latex文档 1234sudo add-apt-repository ppa:lyx-devel/releasesudo apt-get update sudo apt-get install lyxlyx 参考：Here 三、通讯软件1. Skype按照以下命令行进行安装 1234sudo apt-get install gdebiwget https://go.skype.com/skypeforlinux-64-alpha.debsudo gdebi skypeforlinux-64-alpha.deb# from http://www.linuxdiyf.com/linux/22591.html 四、文娱软件1. 网易云音乐官网直接下载deb安装包 五、文件传输1. infinit官网下载deb，然后通过命令行安装 1sudo dpkg -i filename.deb 2. Filezilla官网下载安装，解压后即可使用 六、办公软件1. Zotero官网下载安装包，解压直接运行即可 2. 坚果云官网下载deb，直接安装即可 3. Mega官网下载deb，直接安装即可 4. Teamviewer官网下载deb，直接安装即可 5. Lyx-Latex详情可见Here 专题一：终端配置 安装Terminator 1sudo apt-get install terminator 安装zsh 123sudo apt-get install zsh# 切换终端到zshchsh $USER -s $(which zsh) 安装oh-my-zsh 123456789#curl 下载curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh#wget 下载wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh# 如果上述安装方式出现问题，即 Password: chsh: PAM: Authentication failure,则按如下安装rm -fr .oh-my-zsh/curl -L http://install.ohmyz.sh &gt; install.shsh install.sh 安装插件 语法高亮：zsh-syntax-highlighting 123456cd ~/.oh-my-zsh/custom/pluginsgit clone git://github.com/zsh-users/zsh-syntax-highlighting.gitplugins=( [plugins...] zsh-syntax-highlighting)source ~/.zshrc 自动跳转：autojump 123456git clone https://github.com/joelthelion/autojump.gitcd autojump./install.shplugins=(git osx ruby autojump)# 还需要在zshrc中添加相关语句 专题二：VIM配置 安装VIM 同上 安装Spf13-vim 123git clone https://github.com/spf13/spf13-vim.gitcd spf13-vim./bootstrap.sh 插件安装 OR 安装Maple’s Vim Config 123456git clone git://github.com/humiaozuzu/dot-vimrc.git ~/.vimln -s ~/.vim/vimrc ~/.vimrcgit clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle:BundleInstall 专题三：Netcdf-4配置见开源中国上的相关文档。 专题四：Hexo博客配置 安装nodejs 12wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | shnvm install stable 安装Hexo 1npm install -g hexo-cli 官网教程 其余参见5分钟 搭建免费个人博客 专题五：Indicators安装 安装经典菜单指示器 123sudo add-apt-repository ppa:diesch/testingsudo apt-get updatesudo apt-get install classicmenu-indicator 咖啡因（Caffeine） 123sudo add-apt-repository ppa:caffeine-developers/ppasudo apt-get updatesudo apt-get install caffeine 系统负载资讯 1sudo apt-get install indicator-multiload 参考：Here 专题六：Intel parallel studio xe 安装教程 下载安装包：需要注册并验证教育邮箱，下载链接以及序列号将会发送到邮箱当中 直接解压然后运行./install_GUI.sh 12# error: “32-bit libraries not found on this system” when trying to install the Intel C++ Composersudo apt-get install g++-multilib 添加以下语句到配置文件中.bsahrc 12source /opt/intel/bin/iccvars.sh intel64source /opt/intel/bin/ifortvars.sh intel64 查看安装是否完成 12ifort -vicc -v ​]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string类字符访问成员函数]]></title>
    <url>%2F2017%2F02%2F16%2Fstring%E7%B1%BB%E5%AD%97%E7%AC%A6%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这一部分的内容主要是用于对自定义程序输入或输出文件名这一部分内容做一个进一步的学习，但是不会涉及很多内容，只涉及c_str()，data()和copy(p,n)这三个字符访问成员函数。其他关于string类的成员函数内容可以参见维基百科)。 c_str()，data()和copy(p,n)这三个字符访问成员函数都可以从一个string类对象得到一个C类型的字符数组。 c_str()作用：返回对应于字符串内容的 C 风格零结尾的只读字符串，实现机制是生成一个const char*指针，并指向数组。 示例： 1234567891011#include&lt;string&gt;... const char* c;string s="1234";c = s.c_str(); cout&lt;&lt;c&lt;&lt;endl; //输出：1234s="abcd";cout&lt;&lt;c&lt;&lt;endl; //输出：abcd... 注意： c_str()返回一个客户程序可读不可改的指向字符数组的指针，不需要手动释放或删除这个指针 如上例，这个数组的数据是临时的，当有一个改变这些数据的成员函数被调用后，其中的数据就会失效。因此要么现用先转换，要么把它的数据复制到用户自己可以管理的内存中。 其实上面的c = s.c_str();不是一个好习惯。既然c指针指向的内容容易失效，我们就应该按照上面的方法，那怎么把数据复制出来呢？这就要用到strcpy()等函数（推荐）。 12345678910111213#include&lt;string&gt;... //const char* c; //声明指向常量的指针，其指向的内容不能通过指针改变，但是指针可以指向其他变量//char* c; //未初始化char* c=new char[20];string s="1234";strcpy(c,s.c_str());cout&lt;&lt;c&lt;&lt;endl; //输出：1234s="abcd";cout&lt;&lt;c&lt;&lt;endl; //输出：1234... data()作用：访问基础数组，C++11 后与 c_str() 完全相同 copy()作用：copy(p,n,size_type _Off = 0)-从string类型对象中至多复制n个字符到字符指针p指向的空间中。默认从首字符开始，但是也可以指定，开始的位置（记住从0开始）。返回真正从对象中复制的字符。用户要确保p指向的空间足够保存n个字符，否则有溢出危险。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// basic_string_copy.cpp// compile with: /EHsc /W3#include &lt;string&gt;#include &lt;iostream&gt; int main( )&#123; using namespace std; string str1 ( "1234567890" ); basic_string &lt;char&gt;::iterator str_Iter; char array1 [ 20 ] = &#123; 0 &#125;; char array2 [ 10 ] = &#123; 0 &#125;; basic_string &lt;char&gt;:: pointer array1Ptr = array1; basic_string &lt;char&gt;:: value_type *array2Ptr = array2; cout &lt;&lt; "The original string str1 is: "; for ( str_Iter = str1.begin( ); str_Iter != str1.end( ); str_Iter++ ) cout &lt;&lt; *str_Iter; cout &lt;&lt; endl; basic_string &lt;char&gt;:: size_type nArray1; // Note: string::copy is potentially unsafe, consider // using string::_Copy_s instead. nArray1 = str1.copy ( array1Ptr , 12 ); // C4996 cout &lt;&lt; "The number of copied characters in array1 is: " &lt;&lt; nArray1 &lt;&lt; endl; cout &lt;&lt; "The copied characters array1 is: " &lt;&lt; array1Ptr &lt;&lt; endl; basic_string &lt;char&gt;:: size_type nArray2; // Note: string::copy is potentially unsafe, consider // using string::_Copy_s instead. nArray2 = str1.copy ( array2Ptr , 5 , 6 ); // C4996 cout &lt;&lt; "The number of copied characters in array2 is: " &lt;&lt; nArray2 &lt;&lt; endl; cout &lt;&lt; "The copied characters array2 is: " &lt;&lt; array2Ptr &lt;&lt; endl; ////注意一定要使array3有足够的空间 //char array3[5]=&#123;0&#125;; //basic_string&lt;char&gt;::pointer array3Ptr=array3; //basic_string&lt;char&gt;::size_type nArray3; //nArray3 = str1.copy(array3,9); //错误！！！！ //cout&lt;&lt;"The number of copied characters in array3 is: " // &lt;&lt;nArray3&lt;&lt;endl; //cout&lt;&lt;"The copied characters array3 is: "&lt;&lt;array3Ptr&lt;&lt;endl;&#125; 参考： string中c_str()、data()、copy(p,n)函数的用法 wiki-string (C++标准库)#std::basic_string.E7.B1.BB.E6.A8.A1.E6.9D.BF)]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C海拾贝]]></title>
    <url>%2F2017%2F02%2F15%2FC%E6%B5%B7%E6%8B%BE%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[​ 这是一篇杂文，主要用于记录一些平常阅读C/C++代码coding时看到的比较OK的一些用法，慢慢积累，还是不错的～ 20170215-代码风格基本规范 采用缩进对代码进行分级 建议Fortran代码采用2个空格进行缩进 C 代码采用4个空格进行缩进 适当使用空格进行分段 对功能段为单位对代码进行注释，使代码流程一目了然 函数/子程序前面添加一个注释块，一是分隔代码；而是添加相关说明，包括：函数目的，开发者信息，日期，版本变动历史等 12345!-------------------------------------------------! Purpose: initialize the global variables! Author : SAN ZHANG! Date : 2016/09/19!------------------------------------------------- Fortran 编程规范 do/end do, if/end if 如果中间包括的语句较多，超过一屏显示，建议在end do/end if 后面添加注释对哪个变量循环： 12do iblk = 1, nblkend do !-- loop of iblk enddo / end do 两种写法，建议采用后一种； if 同后面的括弧之间有一个空格 有些规范要求do/if等关键词大写，我们目前采用小写规范；待进一步考察； 在代码的最后添加一行 1! vim:ft=fortran:ts=4:sw=4:nu:et:ai: 以让VIM自动实现缩进、将tab替换成空格等 编写程序时的基本规范 读入参数需要回显到屏幕，以用于记录运行参数和调试； 数量较多的输入，如格点速度文件，可以显示最大、最小值等； 通过 _DEBUG 预定义宏进行调试相关的输出，以防止降低正常运行时的速度 20170215-自定义程序输入或输出文件名以前在自己编程序实践中，很多时候都想在程序运行时通过交互的方式让使用者自行定义某些输入或是输出文件的文件名，但是一直找不到合适的方法实现，但是现在可以通过以下代码实现。 123456789101112131415161718#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;int main() &#123; using namespace std; string filename; cout&lt;&lt;"Enter the name of the file"&lt;&lt;endl; cin&gt;&gt;filename; /* 使用c_str()方法指定输出文件名 */ ofstream fout(filename.c_str()); ... &#125; Tips： 首先必须包含头文件string； 在使用时需要用到string类的c_str()方法； 参考： C++ primer plus - 6 ，人民邮电出版社 20170215-const与指针简便记法（1）const后面的内容为常量： 1234const int p; // p 为常量，初始化后不可更改const int* p; // *p 为常量，不能通过*p改变它指向的内容 int const* p; // *p 为常量，同上int* const p; // p 为常量，初始化后不能再指向其它内容 简便记法（2）1234567891011121314①const int p; ②const int* p; ③int const* p; ④int * const p;⑤const int * const p;⑥int const * const p;/* 将 p 替换为 p is a * 将 * 替换为 point to * 从右往左读 */ 细说const当使用带有const的指针时其实有两种意思。一种指的是你不能修改指针本身的内容（其实就是指向的地址），另一种指的是你不能修改指针指向的内容（其实就是该地址上的数据）。 指向const的指针，它的意思是指针指向的内容是不能被修改的。它有两种写法： 12const int* p; （推荐）int const* p; 第一种可以理解为，p是一个指针，它指向的内容是const int 类型。p本身不用初始化它可以指向任何标示符，但它指向的内容是不能被改变的。 第二种很容易被理解成是p是一个指向int的const指针（指针本身不能被修改），但这样理解是错误的，它也是表示的是指向const的指针（指针指向的内容是不能被修改的），它跟第一种表达的是一个意思。为了避免混淆推荐大家用第一种。 const指针，它的意思是指针本身的值是不能被修改的。它只有一种写法： 1int* const p=一个地址; //(因为指针本身的值是不能被修改的所以它必须被初始化） 这种形式可以被理解为，p是一个指针，这个指针是指向int 的const指针。它指向的值是可以被改变的如*p=3; 还有一种情况是这个指针本身和它指向的内容都是不能被改变的： 12const int* const p=一个地址;int const* const p=一个地址; Tip： 一个规律就是： 指向const的指针（指针指向的内容不能被修改）const关健字总是出现在*的左边而const指针（指针本身不能被修改）const关健字总是出现在*的右边，那不用说两个const中间加个*肯定是指针本身和它指向的内容都是不能被改变的。 参考： const 指针与指向const的指针 如何理解常量指针与指针常量？ C++中指针常量和常量指针的区别 20170302-main函数参数mian()函数参数一般我们所写的主函数都是void main()或是int main(){return 0;}，但是还有一种较为普遍的形式： 12345//firstint main(void)//secondint main(int argc, char *argv[])int main(int argc, char **argv) 其中argc，argv用于在程序运行时将参数传入主程序，其中arg就是argument，即参数。具体含义如下： int argc ： argument count（参数计数） 含义：count of cmd line args，运行程序传送给main函数的命令行参数总个数，注意其包含可执行程序名，因而当argc=1时表示有一个程序名称，其存储在argv[0]中 char *argv[ ]：arguments value / vector(参数值) 含义：pointer to table of cmd line args，字符串数组，用来存放指向字符串参数的指数指针，每个元素指向一个参数，空格分隔参数，其长度为argc，数组下标从0开始，argv[argc]=NULL argv[0]：程序运行时的全路径名 argv[1]：指向程序在DOS命令中执行程序名后的第一个字符串 argv[2]：指向执行程序名后的第二个字符串 … argv[argc]=NULL 在程序中我们可以直接调用这些参数。 参考： main函数的参数argc和argv 20170303-程序运行计时struct timeval原型 12345struct timeval&#123;__time_t tv_sec; /* Seconds. */__suseconds_t tv_usec; /* Microseconds. */&#125;; tv_sec：Epoch到创建struct timeval时的秒数 tv_usec：Epoch到创建struct timeval时的微秒数，即秒后面的零头 Epoch：一个Unix时间戳，表示1970年1月1日00:00:00 UTC，由此得到的时间戳不考虑闰秒 gettimeofday()原型 1234567/* Get the current time of day and timezone information, putting it into *TV and *TZ. If TZ is NULL, *TZ is not filled. Returns 0 on success, -1 on errors. NOTE: This form of timezone information is obsolete. Use the functions and variables declared in &lt;time.h&gt; instead. */extern int gettimeofday (struct timeval *__restrict __tv, __timezone_ptr_t __tz) __THROW __nonnull ((1)); gettimeofday()功能是得到当前时间和时区，分别写到tv和tz中，如果tz为NULL则不向tz写入 example 直接获取当前的时间 1234567891011121314151617#include &lt;sys/time.h&gt;#include &lt;stdio.h&gt; intmain(void)&#123; int i; struct timeval tv; for(i = 0; i &lt; 4; i++)&#123; gettimeofday(&amp;tv, NULL); printf("%d\t%d\n", tv.tv_usec, tv.tv_sec); sleep(1); &#125; return 0;&#125; 测试程序用时 12345678910111213141516171819//此部分内容用于计算time coststruct timeval startTime;struct timeval endTime; /* Start and end times */struct timeval costStart; /*only used for recording the cost*/double totalCost = 0;void cost_start()&#123; gettimeofday(&amp;costStart, NULL);&#125;void cost_end()&#123; double elapsed=0; struct timeval costEnd; gettimeofday(&amp;costEnd, NULL); elapsed = ((costEnd.tv_sec*1000000+costEnd.tv_usec)- (costStart.tv_sec*1000000+costStart.tv_usec))/1000000.0; totalCost += elapsed;&#125; 参考： struct timeval结构体 以及 gettimeofday()函数 百科-epoch 20170609-字符串连接sprintf1sprintf(des, "%.*s %.*s %.*s", 3, "foo", 3, "bar", 3, "baz"); des：目标区域的字符串指针 %.*s：用于控制字符串的长度 可以使用sprintf命令实现将数字转换为字符串。 strcat 原型：char *strcat(char *dest, const char *src); 参数：dest 为目的字符串指针，src 为源字符串指针。 作用：strcat() 会将参数 src 字符串复制到参数 dest 所指的字符串尾部；dest 最后的结束字符 NULL 会被覆盖掉，并在连接后的字符串的尾部再增加一个 NULL。注意：dest 与 src 所指的内存空间不能重叠，且 dest 要有足够的空间来容纳要复制的字符串。 实例: 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; char str[80]; strcpy (str,"these "); strcat (str,"strings "); strcat (str,"are "); strcat (str,"concatenated."); puts (str); return 0;&#125; ​]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++文件读写]]></title>
    <url>%2F2017%2F02%2F15%2FC-C-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[​ 最近编程发现利用C/C++读写二进制文件出了一点问题，嗯，不仅笨且记性也不好，所以就用这篇文档来整理记录一下关于C和C++文件读写的相关内容，以备以后用到可以直接查阅而不用到处瞎找。本文主要分成两个部分，前一小部分对C的文件读写做下简要的回顾，后一大半内容主要都是C++文件I/O。 C文件的I/O文本文件I/O打开文件我们使用fopen()函数来创建一个新文件或者打开一个已有的文件，这个调用会初始化类型位FILE的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。函数原型为： 1FILE *fopen( const char * filename, const char * mode ); 其中，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个： 模式 描述 r 打开一个已有的文本文件，允许读取文件。 w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件；如果文件存在，程序会从文件的开头写入内容。 a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件；如果文件存在，程序会在已有的文件内容中追加内容。 r+ 打开一个文本文件，允许读写文件。 w+ 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 关闭文件我们使用fclose函数来关闭文件，其函数原型为： 12int fclose( FILE *fp ); //函数实际作用：清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。 Tips： 如果成功关闭文件，fclose( ) 函数返回零； 如果关闭文件时发生错误，函数返回 EOF。EOF 是一个定义在头文件 stdio.h 中的常量。 写入文件 fputc() 原型： 1int fputc( int c, FILE *fp ); 作用：把参数 c 的字符值写入到 fp 所指向的输出流中； 返回： 如果写入成功，它会返回写入的字符 如果发生错误，则会返回 EOF fputs() 原型： 1int fputs( const char *s, FILE *fp ); 作用： 把字符串 s 写入到 fp 所指向的输出流中 返回： 如果写入成功，它会返回一个非负值， 如果发生错误，则会返回 EOF。 fprintf() 原型： 12int fprintf( FILE *fp, const char *format, [ argument ]...)// format: 格式字符串，用于格式化写入文件 作用：把一个字符串写入到文件中，直至遇到’\0’ 返回：同上 示例： 1234567891011/* 在 /tmp 目录中创建一个新的文件 test.txt，并使用两个不同的函数写入两行。*/#include &lt;stdio.h&gt;main()&#123; FILE *fp; fp = fopen("/tmp/test.txt", "w+"); fprintf(fp, "This is testing for fprintf...\n"); fputs("This is testing for fputs...\n", fp); fclose(fp);&#125; 读取文件 fputc() 原型： 1int fgetc( FILE * fp ); 作用：从 fp 所指向的输入文件中读取一个字符。 返回： 如果成功，则返回值是读取的字符 如果发生错误则返回 EOF fgets() 原型： 1char *fgets( char *buf, int n, FILE *fp ); 作用：从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 **buf**，并在最后追加一个 **null** 字符来终止字符串。 返回：如果这个函数在读取最后一个字符之前就遇到一个**换行符 &apos;\n&apos; 或文件的末尾 EOF**，则只会返回读取到的字符，包括换行符。 fscanf() 原型： 1int fscanf(FILE*stream,constchar*format,[argument...]); 作用：从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取。 返回：同fgets() 示例： 1234567891011121314151617181920212223/* 首先，fscanf() 方法只读取了 This，因为它在后边遇到了一个空格。* 其次，调用 fgets() 读取剩余的部分，直到行尾。* 最后，调用 fgets() 完整地读取第二行。 */include &lt;stdio.h&gt;int main()&#123; FILE *fp; char buff[255]; fp = fopen("/tmp/test.txt", "r"); fscanf(fp, "%s", buff); printf("1 : %s\n", buff ); fgets(buff, 255, (FILE*)fp); printf("2: %s\n", buff ); fgets(buff, 255, (FILE*)fp); printf("3: %s\n", buff ); fclose(fp);&#125; 运行结果 12341 : This2: is testing for fprintf...3: This is testing for fputs... 二进制 I/O文件打开函数同文本文件打开， 1FILE *fopen( const char * filename, const char * mode ); 但是mode有点区别， 1&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot; 文件关闭同文本文件 写入文件函数原型： 123456789/* buffer：是一个指针，对fwrite来说，是要获取数据的地址; * size_of_elements：要写入内容的单字节数； * number_of_elements：要进行写入size字节的数据项的个数； * a_file：目标文件指针； * 返回实际写入的数据项个数。 × size_t：一般表示是unsigned int类型，它是一个与机器相关 × 的unsigned类型，其大小足以保证存储内存中对象的大小。*/size_t fwrite(const void *buffer, size_t size_of_elements, size_t number_of_elements, FILE *a_file); Tips：写入到文件的哪里？ 这个与文件的打开模式有关， 如果是w+，则是从file pointer指向的地址开始写，替换掉之后的内容，文件的长度可以不变，a_file的位置移动number_of_elements个数； 如果是a+，则从文件的末尾开始添加，文件长度加大。 示例： 12345678910111213141516171819202122#include &lt;stdio.h&gt;struct mystruct&#123; int i; char cha;&#125;; int main(void)&#123; FILE *stream; struct mystruct s; if ((stream = fopen("TEST.$$$", "wb")) == NULL) /* open file TEST.$$$ */ &#123; fprintf(stderr, "Cannot open output file.\n"); return 1; &#125; s.i = 0; s.cha = 'A'; fwrite(&amp;s, sizeof(s), 1, stream); /* 写的struct文件*/ fclose(stream); /*关闭文件*/ return 0;&#125; 读取文件原型： 123456/* 从a_file指向的文件中读取number个数据，每个数据大小为size， * 将其写入到buffer中 * 若调用成功，则返回哦实际读取到的个数，如果不成功或是读到文件 * 末尾则返回零 */size_t fread(void *buffer, size_t size_of_elements, size_t number_of_elements, FILE *a_file); 示例： 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; FILE*stream; char msg[]="this is a test"; char buf[20]; if((stream=fopen("DUMMY.FIL","w+"))==NULL) &#123; fprintf(stderr,"Can not open output file.\n"); return 0; &#125; /*write some data to the file*/ fwrite(msg,1,strlen(msg)+1,stream); /*sizeof（char）=1 seek to the beginning of the file*/ fseek(stream,0,SEEK_SET); /*read the data and display it*/ fread(buf,1,strlen(msg)+1,stream); printf("%s\n",buf); fclose(stream); return 0;&#125; C++文件的I/OC++ 文件I/O同处理标准输入输出的方式非常相似，同时C++在头文件fstream中定义了多个新类，包括①用于文件输入的ifstream类和②用于文件输出的ofstream类，此外还定义了一个③用于同步文件I/O的fstream类，这些类都是从iostream中派生而来的，因此可以将iostream的方法用到文件操作中。常用的两类文件操作： 写人文件：创建一个ofstream对象，并运用ostream方法，如&lt;&lt;或write()方法 读取文件：创建一个ifstream对象，并运用istream方法，如&gt;&gt;或get()方法 C++ 简单I/O示例写入文件1234567891011121314151617181920/* 首先必须包含头文件 * 对大多数实现来说，包含该头文件也就意味着包含了iostream， * 因此不必显式包含iostream */#include&lt;fatream&gt;/* Step1: 声明一个ofstream对象 */ofstream fout;/* Step2: 对象关联特定文件 */fout.fopen("jar.txt");if(!fout.is_open()) exit(1);/* 以上两步骤可以合并为如下的一句命令 */ofstream fout("jat.txt");/* Step 3: 使用cout的方式使用使用该对象 */fout&lt;&lt;"Hello world !";/* Step4: 关闭文件 */fout.close(); Tips： ofstream对象可以使用ostream的所有方法，包括各种插入运算付定义，格式化方法以及控制符等； fstream对象先先从程序中逐字节收集输出，待缓存区满后，再将缓存区中所有内容一同输出目标文件； 以上述方式打开的文件，如果没用这样的文件，将会报错，如果有这样的文件，将会清空内容。 读取文件1234567891011121314151617181920212223/* 首先必须包含头文件 * 对大多数实现来说，包含该头文件也就意味着包含了iostream， * 因此不必显式包含iostream */#include&lt;fatream&gt;/* Step1: 声明一个ifstream对象 */ifstream fin;/* Step2: 对象关联特定文件 */fin.fopen("jellyar.txt");if(!fin.is_open()) exit(1);/* 以上两步骤可以合并为如下的一句命令 */ifstream fin("jellyjat.txt");/* Step 3: 使用cin的方式使用使用该对象 */char ch;fin&gt;&gt;ch; /* 一次读取一个char */char buf[80];fin.getline(buf,80); /* 一次读取一行char *//* Step4: 关闭文件 */fin.close(); 文本文件 基本代码结构同示例，不过在文件打开中，其模式有：| 模式 | 描述 || :———: | ————– || ios::in | 为输入(读)而打开文件 || ios::out | 为输出(写)而打开文件 || ios::ate | 初始位置：文件尾 || ios::app | 所有输出附加在文件末尾 || ios::trunc | 如果文件已存在则先删除该文件 || ios::binary | 以二进制方式对文件进行操作 | Tips：这些打开模式可以组合使用，中间以或操作符”|”间隔，如我们可以 123456/* 以二进制方式打开文件，并在末尾末尾写入数据 */ofstream file;file.open ("example.bin", ios::out | ios::app | ios::binary);/* OR */ofstream file ("example.bin", ios::out | ios::app | ios::binary); 文件打开检查 调用成员函数is_open()来检查一个文件是否已经被顺利的打开，它返回一个布尔(bool)值，为真（true）代表文件已经被顺利打开，假( false )则相反 二进制文件注意事项： 文件的打开关闭操作同示例，但是打开模式中必须要有ios::binary 在二进制文件中，使用&lt;&lt; 和&gt;&gt;，以及函数（如getline）来操作符输入和输出数据，没有什么实际意义，虽然它们是符合语法的。 在二进制文件操作中，其写入和读取数据的函数为write和read成员函数 【转】对于C++文件操作，你以什么模式打开文件根本不重要，因为你既改变不了文件本身的内容，也改变不了C/C++中系统函数的工作方式，所以在编程的时候，你只要关心这个文件里的数据内容本身是二进制格式还是文本格式就好了！如果内容是文本格式的，你就调用文本格式那一套函数，比如puts,gets,fscanf,fprintf,&lt;&lt;,&gt;&gt;等，如果内容是二进制格式的，你就调用二进制格式那一套函数，比如fread,fwrite,ifstream.read(),ofstream.write()等。只要保持文件内容与处理函数相对应相一致就可以了，别管它用什么模式打开文件！！假如你用&lt;&lt;向一个二进制文件中输入一个整数，那么其实里面保存的是文本格式的数据，那么你就照样可以以二进制模式打开它，然后用&gt;&gt;来读取这个整数。相反，如果你的二进制文件里面是一个以二进制形式保存的整数，那你肯定不能用&gt;&gt;来读取里面的整数了！！ 写入文件原型： 12345file.write( char * buffer, streamsize size );/* Notice * buffer的类型必须是(char *),不是此类型的需要强制类型转换, * 它是内存中需要写入到文件的数据的首地址； * size大小的确定一般用count*sizeof(type)获取 示例： 12345678910std::ofstream fout("a.dat", std::iOS::binary);int nNum = 20;std::string str("Hello, world");/* 写入int类型数据 */fout.write((char*)&amp;nNum, sizeof(int));/* 写入字符串 */fout.write(str.c_str(), sizeof(char) * (str.size()));fout.close(); 读取文件原型： 12345file.read ( char * buffer, streamsize size );/* Notice * buffer的类型必须是(char *),不是此类型的需要强制类型转换, * 它是从文件中读取的数据进行存放的空间的首地址； * size同上； */ 示例： 12345678910111213std::ifstream fin("a.dat", std::ios::binary);int nNum;char szBuf[256] = &#123;0&#125;;/* 读取数据存放到nNum中 */fin.read((char*)&amp;nNum, sizeof(int));/* 读取数据存放到szbuf中 */fin.read(szBuf, sizeof(char) * 256);std::cout &lt;&lt; "int = " &lt;&lt; nNum &lt;&lt; std::endl;std::cout &lt;&lt; "str = " &lt;&lt; szBuf &lt;&lt; std::endl;fin.close(); 参考资料： C I/O C 文件读写 百科-fwrite 百科-fread C++ I/O C++ primer plus -6，人民邮电出版社 C++文件操作详解(ifstream、ofstream、fstream) C++读写二进制文件 C++二进制文件写入读取]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++：内存中堆与栈简析]]></title>
    <url>%2F2017%2F02%2F12%2FC-C-%E4%B8%AD%E5%A0%86%E4%B8%8E%E6%A0%88%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[关于C/C++中堆与栈的问题，在之前编程过程中遇到过好多次，每次看一遍就忘了，趁现在有空，就将这个好好的梳理一遍。参考来源已附文末，感谢前辈~ 拓：数据结构中的堆与栈对于堆与栈，其细分有两类：一类是内存中的，而另一类是数据结构中的。对于数据结构中的堆与栈，其比较简单，我们在此就大致介绍一下。 既然属于数据结构，那么堆与栈应该就是存储数据的一种方式： 栈—叠盘子 数据就像盘子一样，刚开始是从下往上叠，但是需要使用时，就是从上往下区，遵循“后进先出”的原则。 堆—书架取书 堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质。 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等 由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。 ​ 程序的内存分配一般而言，由C/C++编译的程序其占用的内存可以分为以下5类： 栈区（stack） 由编译器自动分配释放 ，存放函数参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 通常是用那些在编译期间就能确定其存储大小的变量的存储区，用于在函数作用域内创建、在离开作用域后自动销毁的变量的存储区。通常是局部变量、函数参数等的存储区。它的存储空间是连续的，两个紧挨着的定义的局部变量，它们的存储空间是紧挨着的。栈的大小是有限的，通常Visual C++编译器默认栈的大小是1M（或2M），所以不要定义int a[1000000]这样的超大数组。 堆区（heap） 一般由程序员分配释放 ， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 通常是用于那些在编译期间不能确定存储大小的变量存储区，它的存储空间是不连续的，一般用malloc（或new）函数来分配内存块，并且需要要free（或delete）释放内存。如果程序员没有释放掉，那么就会出现常说的内存泄漏问题。需要注意的是，两个紧挨定义的指针变量，所指向的malloc出来的内存并不一定是紧挨着的。另外需要注意的一点是，堆的大小几乎是不受限制的，理论上每个程序最大可达4GB。 全局区（静态区）(static) 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。 和“栈”一样，通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。 常量存储区 常量字符串就是放在这里的。 程序结束后由系统释放 和“全局/静态存储区”一样，通常是用于那些在编译期间就能确定存储大小的常量存储区，并且在程序运行期间，存储区内的常量也是全局可见的。这是一块比较特殊的存储区，它们里面放的是常量，不允许被修改。 程序代码区 存放函数体的二进制代码 示例：123456789101112int a = 0; //全局初始化区 char *p1; //全局未初始化区 main() &#123; int b; //栈 char s[] = "abc"; //栈 char *p2; //栈 char *p3 = "123456"; //123456\0在常量区，p3在栈上。 static int c =0； //全局（静态）初始化区 p1 = (char *)malloc(10); //堆 p2 = (char *)malloc(20); //堆 &#125; 内存中堆栈的区别申请和回收方式不同 申请方式： 栈：系统自动分配空间 堆：程序员自己分配 回收方式： 栈：系统自动回收，因而其生命周期只是函数作用域内，离开作用域便自动销毁 堆：程序员人为释放，如果不人为释放的话可能会造成内存泄漏。 申请后系统的响应不同 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出（stack overflow）。 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 从而可以看出，堆在申请后还需要一些后续工作，因而效率就不想栈那样高了。 申请效率的不同 栈：由系统自动分配，速度较快。但程序员是无法控制的。 堆：是由new或malloc分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。 申请大小的限制不同 栈：在Windows下栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 堆栈中的存储内容不同 栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 【先进后出】当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 堆栈的存取效率不同在数据相同的情况下，在栈上的数据比指针所指向的数据存取(例如堆)要快。 Tip： 堆和栈的区别可以引用一位前辈的比喻来看出： 使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，它的好处是快捷，但是自由度小。 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 C语言内存管理的几个规则 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存； 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用； 避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作； 动态内存的申请与释放必须配对，防止内存泄漏； 用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。 常见内存错误及其处理方法 内存分配未成功，却使用了它 编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。 内存分配虽然成功，但是尚未初始化就引用它 犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。 内存分配成功并且已经初始化，但操作越过了内存的边界 例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界 忘记了释放内存，造成内存泄露 含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。 动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理） 释放了内存却继续使用它 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针” 综上，内存错误可概括为：分配—初始化—越界—释放—NULL 参考资料： C/C++内存存储问题 C/C++编译的程序占用的内存解析 堆和栈的区别 之 数据结构和内存]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log of BanZhuan]]></title>
    <url>%2F2017%2F02%2F11%2FLog-of-BZ%2F</url>
    <content type="text"><![CDATA[Please enter the password to read. 解密 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]]></content>
      <categories>
        <category>HPC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIC-基本语法]]></title>
    <url>%2F2017%2F02%2F11%2FMIC-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MIC并没有单独的编程语言，MIC编程是对C/C++/Fortran语言的扩展，其使用了编译制导语句。它十分类似于OpenMP，不过MPSS（Intel MIC Platform Software Stack，英特尔MIC平台软件栈）也提供了一些高级API函数接口以便满足不同需求。这篇文章主要对offload模式的MIC编程语法进行一个简单学习。 offload模式关键词offload的作用：在offload作用范围内的程序代码是要在MIC卡上运行的。offload语句用于CPU与MIC的主从模式。 offload基本语句123456789C/C++:#pragma offloadFortran：！dec$ OFFLOAD //后面必须紧跟OpenMP语句或是函数调用语句或！DIR$ OFFLOAD BEGIN ……！除了OpenMP以外的其他语句，如do，call语句 //不能使用OpenMP语句！DIR$ END OFFLOAD SIMD模型：如果一个程序的主要代码集中在for循环中，那么他就是典型的SIMD，即每次循环迭代，都拥有相同的指令，只是数据各不相同。 Tips： 移植到MIC上，只需加上上面的编译制导语句 编译时不需要任何特殊的编译选项，默认为MIC程序，若要编译成CPU程序，则需要加入-no-offload。 普通的循环程序代码加上offload语句后，其在MIC上仍然是串行执行的（只用到了MIC一个核的一个硬件线程）。offload语句本身只是起到了指示编译器将代码放入设备端运行的作用，并不指示代码并行执行。若想实现在MIC上的并行，则需要在设备端使用OpenMP。 程序移植所需工作 移植到MIC上，只需加上上面的编译制导语句 编译时不需要任何特殊的编译选项，默认为MIC程序，若要编译成CPU程序，则需要加入-no-offload。 普通的循环程序代码加上offload语句后，其在MIC上仍然是串行执行的（只用到了MIC一个核的一个硬件线程）。offload语句本身只是起到了指示编译器将代码放入设备端运行的作用，并不指示代码并行执行。若想实现在MIC上的并行，则需要在设备端使用OpenMP。 Tips：判断程序是否在MIC执行：MIC提供了一个检查宏_MIC_（相关语法在后面涉及） 123456789C/C++:_attribute_((target(mic)))void funcheck(int i)&#123;#ifdef_MIC_ printf("Index on MIC:%d\n",i);#else printf("Index on CPU:%d\n",i);#endif&#125; MIC数据传输Tips： 不建议在设备端使用打印或是输出语句 使用引语编程的一个好处便是使用一套代码就可以满足不同模型，只要不加上相应的编译选项，就不会使用该特性 关键字 out：通知编译器，括号内的变量/数组是需要输出的，这样驱动就会在代码离开MIC卡时，将变量拷贝到内存中相应的位置中。 注意： 若是在栈上声明的数组，其长度在编译时就已经确定，所以不需要在传输时标注长度，但是若是在堆上声明的数组，由于编译时大小不能确定，因此必须在传输时标注数组大小。关于堆栈的内容可以参考我的另外一篇博文：C/C++中堆与栈简析 非数组的变量若不显式传值，一旦MIC用到，就会自动以inout方式传递。 in：输入，在设备端开辟空间并将主机端数据复制到设备端 inout：输入并输出，在设备端开辟空间，在进入设备端时将数据复制到设备端，在从设备端离开时，将数据从设备端复制到主机端。 nocopy：不拷贝。仅在设备端建立空间，不复制数据。但是需要在CPU端声明 12_attribute_((target(mic)))float* a; //a是中间变量，因此不需要再CPU端申请空间，但是必须声明为全局变量，且加上attribute前缀。#pragma offload target(mic:0)nocopy(a:length(LEN) alloc_if(1) free_if(0)) //示例 Tips：nocopy使用场合 在不同的offload区域（offload两次），如果后一次需要用到的前一次计算后的某些变量和数据，则可以使用nocopy避免数据内存中转，造成浪费（#pragma offload nocopy(a)） 变量作为设备代码段中的临时变量（不需从主机赋初值，也不需传回主机） Rule of thumbs一般规则 传输关键字可以有多个或零个，当多个时：可以连续书写，也可以用逗号或空格隔开。相同的关键字可以在一个offload语句中出现多次，但相同的变量名不可以在一个offload中出现多次（即使是在不同的关键字中）； 传输关键字后跟括号，括号内为变量名； 变量应为数组名或是指针（特指动态数组指针）或普通标量，多个变量之间用逗号隔开； 变量为指针时，指针只能指向非指针变量，即不支持二维指针。 变量为数组或是指向数组的指针时，可以指定数组起始与长度； 变量为指针时，需要在变量名后面加上”：length（len）”，其中len为动态数组的元素个数，若多个动态数组长度相同，则可以写在一起，如：in（a，b，c：length（20））。元素个数可以是变量 除了length以外，还有alloc_if、free_if、align、alloc、into等五个关键字，一个传输关键字用一个冒号即可 alloc_if和free_if的参数是判断表达式，其计算结果应该是布尔型。若alloc_if的参数结果为真则在进入设备端是为前述变量开辟空间，若free_if的参数结果为真则在离开设备端时为前述变量释放空间。 align的参数时一个正整数，且必须是2的正整数次幂，其含义为在设备端开辟的前述变量，以align参数的长度对齐 alloc的参数是数组名，含义是创建指定的部分内存空间 into的参数是变量或是数组名，但只能一对一传递，含义为将数组中主机端拷贝到设备端的另一个数组，或相反。into可以和alloc，alloc_if，free_if结合使用，但不能与inout，nocopy同时使用。 示例讲解：P92 in/out/inout的实用语法123456789101112131415/* 使用in out inout 传递部分数组 */1 typedef int Array[10][10];2 int a[1000][500];3 int *p;4 Array *q;5 int *r[10][10]6 int i,j;7 struct &#123; int y; &#125; x;8 #pragma offload ... in(a);9 #pragma offload ... out(a[i:j][:])10 #pragma offload ... in(p[0:100])11 #pragma offload ... in((*q)[5][:])12 #pragma offload ... out(x,y) ​ 8：最常用的数组引用方法，传输全部数据 9：传输数组a的一部分，其中[i:j]规范第一维，i表示起始位置，j表示个数，第二维中只有冒号，省略了前后，表示第二维是完整的。长度参数可以是变量。 10：即使传输的是指向动态数组的指针，也可以用数组的“[ ]”表示。 11：第一维只有一个参数5，意味第一维只有一个元素 12：表示可以传输结构体的一部分 注意：需要注意的是，虽然传输的是数组的一部分，但在MIC卡端开辟内存空间时，仍然开辟了从第一个元素开始的全部空间，所以一方面这种写法并没有减少内存使用，另一方面在使用时仍然要将数组视为整体使用。 针对此种写法的关键字：alloc和into 由于传输部分数组的语法会开辟全部的内存空间，因此可以使用alloc语法限定开辟的空间范围 1234/* 下述语句：* ①在设备端开辟1000个元素的数组p，数组下标从5开始，到1004；* ②将主机端的p[10]-p[109]传到设备端的p[10]-p[109]，检查数据越界的责任仍然是程序员。 */pragma offload ... in (p[10:100]:alloc(p[5:1000]) into语句可以将主机端的数据数组一部分传递给另一个设备数组 12/* 使用这种方式需要注意数组覆盖的情况。另外还要注意的就是into不能实现不同维度数组间的数据传递。*/#pragma offload ... in (p[0:500]:into(p1[500:500])) 其他一些关键字target target（mic)：mic是目前唯一合法的取值。在运行时可以指定使用第几块mic卡，用法是在mic后加冒号并附加序号，如target（mic：1），序号应注意： 当序号大于等于0时，程序将offload到相应设备设备上，设备号计算方法：设备号=序号mod总设备数（取余） 当序号等于-1时，系统自动选择计算设备 序号不可小于-1 使用多块MIC卡协同计算的OpenMP循环代码 1234567omp_set_nested(1); //嵌套OpenMP代码#pragma parallel for num_threads(3) //假设有两块MIC卡，和CPU协同计算for(i=0;i&lt;3;i++)&#123;#pragma offload target(mic:i) if(i&gt;1) in(...) out(...)...&#125; 以上代码将第一份任务指定给了CPU，第2,3份指定给了两块不同的MIC卡。由于使用了嵌套OpenMP代码，因此需要调用第一句。 在offload之前，可以使用API函数 int\_Offload\_number\_of\_devices(void)确定系统拥有的MIC设备数。在offload的代码段里，可以使用API函数int\_Offload\_get\_device\_number(void)获取该代码段所在的设备编号。 if根据条件判断是否要将代码段放到设备上运行，若表达式为真，则在MIC端运行，否则在CPU端运行（如上代码） mandatory 表示该代码必须在MIC上运行，若设备不可用，直接报错。 不可与if同时使用。 异步传输 signal和wait：即CPU端无需等待offload语句返回，即可异步运行下面的代码。一般用于启动MIC代码段后，并发执行CPU代码，达到同步执行的目的 offload_transfer和offload_wait：与offload类似，只负责数据传输，后面不加入计算代码。其中offload_transfer支持的参数与offload语句相同，但offload只支持target、if、wait三个参数 用法： signal语句在offload语句代码段结束后发送一个信号，wait语句负责接收，所以二者一定是成对使用 wait语句可以一次等待多个信号，所以二者语句数量未必相等 signal 和 wait的参数是tag，在C中，是数组指针，同时传输多个数组指针时，能且只能signal/wait一个数组名。在Fortran中，该变量是一个整型变量。 offload语法总结12/* 使用格式 */#pragma offload specifier[，specifier ...] 其中，specifier可填入：target，if，in，out，inout，nocopy，signal，wait，mandatory，而在in/out/inout/nocopy可用属性有：length，alloc_if，free_if，align，alloc，into。 变量与函数声明单个声明方式1234567C/C++：_declsspec(target(mic))函数或变量声明或_attribute_((target(mic)))函数或变量声明Fortran：!DIR$ attributes offload: target-name :: routine 名或变量名[，routine 名或变量名]... 批量声明方式12345678910111213C/C++：#pragma offload_attribute（push, target(mic)) 变量或函数声明；#pragma offload_attribute(pop)或#pragma offload_attribute( target(mic)) 变量或函数声明；#pragma offload_attribute( target(none))Fortran：!DIR$ OPTIONS /OFFLOAD_ATTRIBUTE_TARGET=mic 变量或函数声明；!DIR$ END OPTIONS 注意： 在C/C++中，使用attribute的话，需要注意target外围是两层括号，只写一层是错的 上述声明方式适用于函数与变量，变量是全局变量 函数和变量可以同时用于CPU与MIC MIC程序编译运行注意事项头文件 在C/C++中，在MIC中若要用到API，需包含offload.h 在Fortran中，需要include mic_lib.f90或USE mic_lib 环境变量 MIC_STACKSIZE：规定MIC上每个线程所占的栈的大小，默认2MB，可以修改： 1export MIC_STACKSIZE=5M MIC_ENV_PREFIX：可以设置MIC专属环境变量的前缀，以区分MIC端和CPU端的环境变量，若不加以却别，默认情况下，CPU端的环境变量会作用于MIC端，示例： 123export OMP_NUM_THREADS=8export MIC_OMP_NUM_THREADS=124export MIC_ENV_PREFIX=MIC_ 使用方法如下：定义一个前缀“MIC_”，若MIC上有环境变量符合前缀，则去掉前缀，并将其作用于MIC上。 MIC_LD_LIBRARY_PATH：定义了程序在MIC上运行时所需要用到的共享库路径，此处的共享库路径指MIC卡上的地址，即需要手动将共享库传输到MIC端，路径一般指向用户自己编写的共享库。由于主机端的LD_LIBRARY_PATH不会自动扩展到MIC上，因此不需要结合上面的环境变量 编译选项 -mmic：表示编译出的程序只能在MIC上运行。默认不开启，不开启时编译产生的程序是异构程序。 -no-offload：表示编译出的程序只能在CPU上运行，使用这个选项时，将忽略程序中所有与MIC相关的语句。默认不开启，开启时编译产生的程序是纯CPU程序。 -offload-attribute-target=mic：表示所有未声明为mic可用的函数和全局变量都可以在MIC中使用，与在代码中使用attribute属性声明函数或变量的效果相同。默认不开启。 -offload-option，target，tool，&quot;option-list&quot;：作用为针对被offload的对象，即在MIC卡上运行的代码段，使用特殊的编译选项。其中target只能选mic，tool只能取ld（链接库时用到的程序），as（汇编器）或compiler（编译器）之一，option-list是具体的选项，必须用引号括起来，选项之间用空格分开。 注意： MIC程序的编译选项与CPU程序无多大差别，绝大多数的CPU程序编译选项也能在MIC程序中使用 异构程序编译时，使用的编译选项会全部传递给主机端编译程序。有一部分（MIC支持的部分）会被传递给MIC端编译程序，可以通过&quot;-watch=mic-cmd&quot;查看 使用offload-option（上述第4点）增加的编译选项，只能在MIC端使用，并且会覆盖或附加在CPU端过去的编译选项之后。若想覆盖，则需要将-offload-load写在自动传输的参数前面，若-offload-option选项被写在后面，则会附加到自动传输的参数后面。 其他问题 在offload区域只能正常退出，使用exit（）会报错 在Fortran中在外部函数/subroutine中定义的变量不能通过offload语句传递给内部/subroutine，但是SAVE变量不受约束。 参考资料： MIC高性能计算编程指南，王恩东，中国水利水电出版社，2012]]></content>
      <categories>
        <category>HPC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIC-HelloWorld]]></title>
    <url>%2F2017%2F02%2F11%2FMIC-Hello-world%2F</url>
    <content type="text"><![CDATA[从这部分内容开始，我将对MIC高性能计算进行一个比较系统的学习，周期大致为2017年上半年，努力争取完成这个小目标。 这篇内容主要是对MIC(Many Intergrated Cores)做一个简单介绍，并利用中国科大超算中心（SCC）ChinaGrid服务器上的MIC计算节点进行简单测试，在此感谢SCC提供的技术与服务支持！ MIC高性能计算简介现状简介目前主流的集群架构系统： CPU同构架构系统； CPU+GPU异构架构系统：以CPU为主体，主要运行逻辑计算部分，而GPU进行密集运算，两者属于不同指令集下的异构； CPU+MIC异构架构系统：基于x86架构的异构计算，MIC的基本指令集与CPU一样，采用x86指令集，并有部分扩展。 计算机体系结构分类（根据指令与数据流，Flynn分类法） 单指令流单数据流计算机（SISD）——批处理机模型 单指令流多数据流计算机（SIMD） 多指令流单数据流计算机（MISD）——少见 多指令流多数据流计算机（MIMD） 在商用并行计算机中，MIMD模型最为通用，SIMD次之。 目前高性能计算技术（并行计算的硬件） 对称多处理机（Symmetric MultiProcessing，SMP）：一种多处理机硬件架构，有两个或更多的相同的处理机（处理器）共享同一主存，由一个操作系统控制。对称多处理架构将多核处理器中的核作为不同的处理器。在进行并行编程时，通常使用线程的任务划分，使用OpenMP扩展或是pThread线程库。 集群（Cluster）：通常指一组计算机（一般为服务器级别的硬件）通过网络松散集成，组成局域网，并紧密合作完成计算任务的结构。由于并非共享内存结构，因此通常采用消息传递方式，如MPI，进行进程级的并行。 松散集成：是相对于在电路板上或是通过高速总线相连接来说的，一般集群中的计算机结点可以单独使用。 紧密合作：指节点间通常相互协作完成同一任务，而非各自为政。 通用图形处理器（GPGPU，General-purpose computing on graphics processing units）：是一种利用处理图形任务的图形处理器来计算原本由中央处理器处理的通用计算任务。这些通用计算常常与图形处理没有任何关系。 统一设备计算架构（Compute Unified Device Architecture，CUDA）：将GPU作为数据并行计算设备的软硬件系统。 开放计算语言（Open Computing Language，OpenCL），开放图形库（OpenGL），OpenAL MIC（Many Integrated Core）什么是MICMIC指的是基于集成众核架构的至强融核系列。其是将多个核心整合在一起的处理器，面向HPC领域，旨在引领行业进入百亿亿次计算的时代，其在计算机体系中，并非要取代CPU，而是作为协处理器存在。MIC芯片通常有数十个精简的x86核心，提供高度并行的计算能力。另外，与其他协处理器不同的是，原生CPU程序（支持C/C++以及Fortran）也可以在MIC上运行，对现有程序无须大的改动。MIC采用SMP结构，以一致性共享缓存为中心。 一些名词： MIC：架构名称； Knights系列：研发代号 Intel Xeon Phi：产品线名称 GPGPU与MIC比较 CUDA与MIC中“核”的概念不同，但由于有超线程，MIC中的“执行核”数与GPGPU实际差不多； MIC采用SMP结构，以一致性共享缓存为中心，使MIC可以使用传统CPU的编程模型； MIC编程与工具方面没有较大的改动； GPGPU适用于并行程度极高，分支较少的应用，而MIC适用于并行程度较高，逻辑（分支以及循环等指令）比较复杂的应用。 MIC编程MIC编程模型 应用程序编程：利用开发工具开发用户应用程序或代码； 系统编程：使用低级API的编程（SCIF），低级API的内容包含在MPSS（Intel MIC Platform Software stack）中。 MIC应用模式简单分为三种（依据串行与并行之间的权重） CPU为中心模式： CPU原生模式（native模式） 采用纯CPU计算：适于串行或并行程度较低的并行程序； 编译选项：-no-offload CPU为主MIC为辅模式（offload模式） 以CPU为中心，MIC协同计算：适于串行计算程序中包含高度并行计算的部分。 程序主函数由CPU发起，执行到并行部分交由MIC计算； 此时可以将CPU端称为主机端，或host端，而将MIC端称为设备端，或device端； 编程形式类似于OpenMP，通过编译制导语句标示欲并行计算的代码。通常，offload语句会与OpenMP语句相结合，以使用MIC设备并行化执行。 这种模式类似于GPGPU：串行执行—并行部分—串行执行。 关于offload： offload相关的语义： 指offload代码，又称为offload语句 指使用offload语句编程、运行的模式，即offload模式 指将代码段运行于协处理器上的动作 offload模式的适用情况 常用于单节点，且/或已被OpenMP改造过的程序； 支持单机单MIC卡和单机多MIC卡，但不支持使用offload语句控制多节点。若是多节点并行，需在外围框架中使用MPI进行数据传输，内部则使用offload+OpenMP模式； 欲改造现有串行程序使用offload模式并行，则需要： ①确定欲并行的部分，并将其改写成OpenMP并行程序； ②确定输入输出变量之后，书写相应的offload语句。 MIC为中心模式 MIC原生模式 采用纯MIC计算：适于高并行计算程序，直接在MIC运行。如部分划给CPU执行，反而会增加通信等额外开销。 MIC拥有自己的基于Linux的操作系统，且拥有自己的IP地址。支持卡上运行模式，将程序与数据传输到MIC卡上，并直接在MIC卡上运行程序。 MIC为主CPU为辅模式 以MIC为中心，CPU协同计算：适于高并行计算程序中包含部分串行计算部分，程序主函数有MIC发起，执行到串行部分交由CPU，在此CPU作为协处理器。 Tips： 卡上原生运行MIC程序的模式适用于： 程序整体算法是并行的； 传输、同步开销过大的程序 原生模式运行事项： 编译选项：-mmic； 如此编译的程序只能在MIC端运行而不能在CPU端运行，因此在使用时需用编译两份代码； CPU与MIC对等模式 对等模式 适于多进程并行程序，如MPI程序，程序主函数在CPU与MIC端同时发起。 在这种模式下，与跨节点并行相同，都需要使用MPI函数接口进行通信。 不需要offload语句进行标示，全部程序的副本在MIC端运行。 CPU与MIC的工作分配 当MIC与CPU协同工作时，CPU负责进行逻辑性强的事务处理与串行计算，MIC负责并行计算部分。他们各自拥有独立的存储器地址空间：主机端内存和设备端内存。主机端与设备端的数据交换通过API函数或是编译器指令实现。 MIC程序与传统的CPU程序相比，增加的只有指示将代码在设备端运行以及相应的数据传输语句而已。 MIC采用的是MIMD架构，既支持SIMD并行方式，也可以通过pThread、MPI等方式是现在不同计算核心上运行不同的指令。 MIC原生程序示例—计算Pi程序源码12345678910111213141516171819202122/* mic_pi.c */#include&lt;stdio.h&gt;#incllude&lt;stdlib.h&gt;#include&lt;math.h&gt;int main()&#123; float pi=0.0f; int count = 1000; int i;// #pragma offload target(mic) //以MIC原生模式运行，不需要offload语句#pragma omp parallel for reduction(+:pi) for(i=0;i&lt;count;i++) &#123; float t=(float)((i+0.5f)/count); pi+=4.0f/(1.0f+t*t); &#125; pi/=count; printf("Pi=%f\n",pi);&#125; 编译指令1#icc mic_pi.c -openmp -mmic -o mic_pi -mmic表示以原生模式运行，编译后的文件无法在CPU端运行。从左到右依次为：编译器，输入文件，编译选项*3，输出文件 运行指令1./mic_pi 参考资料： MIC高性能计算编程指南，王恩东，中国水利水电出版社，2012 Intel C/C++、Fortran编译器的使用 Intel MIC高性能计算服务器使用指南]]></content>
      <categories>
        <category>HPC</category>
      </categories>
      <tags>
        <tag>MIC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPEG函数库使用指南]]></title>
    <url>%2F2017%2F02%2F10%2FJPEG%E5%87%BD%E6%95%B0%E5%BA%93%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[这篇文档可以看成是Example那篇文档的一个辅助文档，若是要自己开发并将JPEG的解压缩功能用于自己的程序中，建议结合这两篇文档。更多细节参阅原文档。 概览IJG JPEG库函数提供了C代码编写的程序用于读写JPEG压缩的图像文件，外围应用程序可以一次发送或是接收a scanline的未压缩的图像数据。另外，该函数库还可以解决颜色转换以及预处理/后置处理等问题。 IJG JPEG只能解决interchange JPEG数据流，特别是广泛使用的JFIF文件格式。它也可以被内嵌在更复杂的代码中用于处理interchange or abbreviated的JPEG数据流中。 库函数基本用法数据格式标准输入图像格式是像素点的矩形阵列，其中每一个像素有着相同数目的“组成”或说“样点”（颜色通道）。你必须指定每个像素点有多少组成以及这些组成成分的颜色空间解释。大部分的应用将会使用RGB数据（每一个像素点有3种颜色成分）或是灰度数据（每个像素点只有一个颜色成分）。必须强调的是RGB数据每个像素点有三个样点值，而灰度数据每个像素点为一个样点值。 在这没有提供颜色表的输入。JPEG文件通常都是全彩或是全灰的（或者有时也会是其他的颜色空间，例如CMYK）。我们可以通过扩展一个colormapped的图像到全颜色空间格式来实现将其颜色填满。然而由于抖动干扰的存在，JPEG通常对来自colormapped的源数据处理不是很好。 像素点通过scanlines存储，在每一个scanline中，从左到右排列。对于在每一个像素点中的组成成分，它们中行中是相邻排列的，例如对于24位的RGB颜色，其每一行排列为：R,G,B,R,G,B…每一个scanline是一个数据类型为JSAMPLE的数组，JSAMPLE类型通常表示无符号字符型，除非你改变了头文件jmorecfg.h。（我们也可以改变RGB像素点的排布方式，也就是R，G，B的排列方式，同样需要在jmorecfg.h中修改）。 通过一列指向scanlines开头的指针，一个2维像素点阵列就可以形成，因此这些scanlines在物理内存中是不需要相邻的。即使你每次只处理一条scanline，你也必须创建一个单个元素的指针数组来符合这个结构。指向JSAMPLE行的指针类型是JSAMPROW，而指向指针数组的指针类型位JSAMPARRAY。 在每一次调用过程中，库函数接收或是提供一个或是多个完整的scanlines。一次处理一行scanline的部分是不可能的。并且scanlines都是从上往下处理。如果一整个图像数据都在内存中，那么我们可以一次处理所有图像数据，但是最简单的还是一次处理一行scanline。 为了使结果最好，源数据数值的精度通过BITS_IN_JSAMPLE（通常是8位）来指定。例如，如果我们选择的数据是每通道6位的，那么我们应该在将数据传递给压缩器之前，将一个字节中每一个数值向左对齐。如果我们需要压缩的数据超过每通道8位 ，我们需要加入编译选项 BITS_IN_JSAMPLE=9 to 12（详情见Library compile-timoptions） 由解压缩器返回得到的数据格式与前面几乎相同，除了它对colormapped的数据输出也是支持的。（再次声明，一个JPEG文件是不能colormapped，但是我们可以让解压缩器通过颜色量化表产生colormapped output。）如果我们要求的是colormapped output，那么返回的数据阵列包含的是每个像素单个JSAMPLE，这个JSAMPLE的值是一个颜色表的索引。这个颜色表以一个2维的JSAMPARRAY呈现，其中每一行包含一个颜色组成的值，也就是说，colormap[i][j]表示的像素值（索引）j的第i个颜色成分的数值。注意，由于颜色表的索引值存储在JSAMPLEs中，颜色的最大数值是由JSAMPLE的大小限制的（例如，对于8位的JPEG库而言，最多 有256种颜色）。 JPEG压缩的具体细节分配和初始化JPEG压缩对象一个JPEG压缩对象就是一个struct jpeg_compress_struct。如果单个子例程序将执行整个JPEG压缩的话，那么这个结构体在调用的子例函数中可以作为一个局部变量。否则它可以使静态的会使从malloc()中分配。 我们同时还需要定义一个错误处理的结构体对象，即struct jpeg_error_mgr。如果我们想用自己的错误处理方式，我们一般需要将上述结构体嵌入到一个 更大的结构体当中（详情可见“Error handling”）。默认的错误处理方式将会打印出错误/警告信息，并且在发送严重错误后调用exit()退出。 我们必须初始化错误处理结构体，之后调用jpeg_create_compress来初始化JPEG对象的其他部分。 如果我们使用默认处理方式，那么这部分的代码应为 12345struct jpeg_compress_struct cinfo;struct jpeg_error_mgr jerr;...cinfo.err=jpeg_std_error(&amp;jerr);jpeg_create_compress(&amp;cinfo); Tips：调用jpeg_create_compress将会分配一小块内存，因此如果内存溢出的话它将会分配失败。在那种情况下，通过错误处理句柄，程序就会退出，这就是为什么错误处理方式必须首先初始化。 指定压缩数据的目的地（例如某个文件）JPEG库函数将会把压缩数据传送到一个数据目的地模块中，这个模块知道如何将数据写入到标准输入输出流中。如果我们想进行其他操作的话，我们可以使用我们自己的目的地模块。但是在jpeg_start_compress和jpeg_finish_compress之间我们不能改变数据目的地。 如果我们使用标准的目的地模块，我们首先必须打开目标输入输出流，对于这一步典型的代码应为： 1234567FILE * outfile;...if((outfile=fopen(filename,"wb"))==NULL)&#123; fprintf(stderr,"can't open %s\n",filename); exit(1);&#125;jpeg_stdio_dest(&amp;cinfo,outfile); 其中最后一行调用了标准目的地模块。 设定压缩参数，包括图像大小以及颜色空间等在开始压缩数据之前必须要为JPEG对象（cinfo structure）指定几个参数和缺省参数。 设定缺省参数之前需要指定的几个参数是： 图像宽度：cinfo.image_width， 图像高度：cinfo.image_height，JPEG支持的宽度和高度在两个方向上可为1~64K， 图像的颜色通道数：cinfo.input_components（比如RGB图像为3，灰度图为1）， 图像颜色空间：cinfo.in_color_space（比如真彩色 JCS_RGB，灰度图JCS_GRAYSCALE）。 JPEG有大量的压缩参数可供选择，但是大部分应用并不需要知道这所有的参数，因此我们可以通过调动jpeg_set_defaults()来将参数全部设置为合理值，然后，如果我们想改变某个特定参数，我们就可以在其后进行改变。 注意：在调用jpeg_set_defaults()之前我们必须设置cinfo.in_color_space，因为默认设置依赖于源图像的颜色空间。但是其他三个参数直到调用jpeg_start_compress之前都不是必须的。另外，多次调用jpeg_set_defaults()是允许的。 对于24位的RGB源图像，典型的代码如下： 123456cinfo.image_width = Width; /* image width and height, in pixels */cinfo.image_height = Height;cinfo.input_components = 3; /* # of color components per pixel */cinfo.in_color_space = JCS_RGB; /* colorspace of input image */jpeg_set_defaults(&amp;cinfo);/* Make optional parameter settings here */ 开始压缩：jpeg_start_compress(…)调用jpeg_start_compress()将会开始压缩循环，这将会初始化一个内部状态，分配一个工作内存，并且发送一些JPEG数据流头部的字节内容。 这一部分的典型代码为： 1jpeg_start_compress(&amp;cinfo, TRUE); 注意：“TRUE”将会确保一个完整的可互换的数据流将被写入。另外，一旦调用了上述函数开始压缩，我们就不能改变任何JPEG的参数或是JPEG对象的某些域值，直到压缩循环结束。 压缩循环操作我们通过调用jpeg_write_scanlines()可以一次写入一条或多条scanlines，在大部分应用中，一般以一次一条或几条为宜。另外，图像数据将按照从上到下的顺序写入（出于兼容性考虑）。 在JPEG对象的next_scanline域中存有到目前位置已经写入的scanlines的数目，因此我们可以直接使用该变量作为循环变量。 这一部分的典型代码位： 1234567JSAMPROW row_pointer[1]; /* pointer to a single row */int row_stride; /* physical row width in buffer */row_stride = image_width * 3; /* JSAMPLEs per row in image_buffer */while (cinfo.next_scanline &lt; cinfo.image_height) &#123; row_pointer[0] = &amp; image_buffer[cinfo.next_scanline * row_stride]; jpeg_write_scanlines(&amp;cinfo, row_pointer, 1);&#125; jpeg_write_scanlines()的返回值是实际写入的scanlines的数目，它等同于传递进去的scanlines的数目，所以通常我们可以忽略这个返回值，但在两种情况下它们有所不同（详见libjpeg.txt）。 结束压缩：jpeg_finish_compress(…)在所有的图像数据都被写入以后，调用jpeg_finish_compress来完成压缩循环。同时它也会释放与JPEG对象相联系的工作内存。 这一部分的典型代码为： 1jpeg_finish_compress(&amp;cinfo); 注意： 如果我们的模式是multi-pass模式，例如HUffman 编码优化，上述函数将会使用第一次传递的缓存数据执行额外的传递操作。在这种情况下，调用这个函数将会花费较长的时间完成操作。但是在默认参数设置下，这种情况将不会发生。 在写入全部数目的scanlines之前调用上述函数将会发生错误，如果希望退出压缩，我们应该调用jpeg_abort()。 在完成压缩之后，我们可以将JPEG对象释放掉，也可以将它用于压缩其他图像，在那种情况下，我们只需重复步骤2,3,4。如果我们不改变目的地管理器，那么新的数据流将会被写入相同的目标文件中；如果我们不改变任何JPEG参数，新的数据就将会按照之前的参数设置写入。如果我们改变了颜色空间，我们需要调用jpeg_set_defaults()来适应新的颜色空间，进而我们需要重复第三部的所有操作。 释放JPEG压缩对象我们可以通过调用jpeg_destroy_compress()来释放JPEG压缩对象，它将会释放所有的附属内存。或者我们也可通过调用jpeg_destroy()来释放，这个函数既可以使用与JPEG压缩对象也可以是解压缩对象。 这一部分的典型代码为： 1jpeg_destroy_compress(&amp;cinfo); 中止退出如果我们想在压缩结束之前就中止循环，我们可以通过以下任意一种方式来清理内存： 如果我们不再需要JPEG压缩对象，我们就像步骤7一样，直接释放内存。这在调用了jpeg_start_compress()之后都是合理的； 如我我们打算重复利用JPEG对象，那么就调用jpeg_abort_compress()或者是jpeg_abort()。这将会使对象回到一个空闲状态，并且释放掉了所有的工作内存。在对象成功创建之后，任何时候调用jpeg_abort()都是允许的。 JPEG解压缩具体细节分配和初始化JPEG解压缩对象同初始化JPEG压缩对象类似，除了使用的结构体不同，错误处理方式也与前面的相同。另外，在IJG代码中，我们一般都会使用cinfo作为压缩和解压缩对象。 这一部分的典型代码： 12345struct jpeg_decompress_struct cinfo;struct jpeg_error_mgr jerr;...cinfo.err = jpeg_std_error(&amp;jerr);jpeg_create_decompress(&amp;cinfo); 指定压缩数据的来源（例如一个文件）正如前面所说的，JPEG库将会从数据源模块中读取压缩数据。函数库中已经包含了一个能从标准输入输出流中读取数据的数据源模块。如果我们使用标准数据源模块，我们必须先打开数据源的标准输入输出数据流。 这一步的典型代码如下： 1234567FILE * infile;...if ((infile = fopen(filename, "rb")) == NULL) &#123;fprintf(stderr, "can't open %s\n", filename);exit(1);&#125;jpeg_stdio_src(&amp;cinfo, infile); //invoke the standard source modue Tip：在调用jpeg_read_header()之后和jpeg_finish_decompress()之前，我们一般不能改变数据流的来源。因此，如果我们从单一数据源文件中读取一系列JPEG文件，我们需要重复jpeg_read_header()和jpeg_finish_decompress()之间的代码，但是不需要重新初始化JPEG对象以及数据源模块（也就是不需要改变输入数据的文件） 调用jpeg_read_header()获得图片的信息该函数将会从数据数据中读取图像中的头文件部分，直到压缩数据的开始位置。返回得到的图像大小以及其他信息将会存储在JPEG对象中，也就是cinfo中 这一部分的典型代码为： 1jpeg_raed_header(&amp;cinfo, TRUE); Tip：如果我们只想获得图片的一些信息，那么我们可以在这一步就中止，我们需要调用jpeg_destroy()或是jpeg_abort()来完成这一操作 设置解压缩参数在调用上上述步骤的函数后，jpeg_raed_header()已经设置了合适的默认解压缩参数（基于其获取到的图片信息）。如果我们想更改一些默认参数，我们可以在这一步设置。具体的设置可以参见Decompression parameter selection 开始解压缩：jpeg_start_decompress()调用以该函数后，它将会初始化程序内部状态，分配工作内存以及准备返回值。 这一步的典型代码为： 1jpeg_start_decompress(&amp;cinfo); 另外，在这次调用之后，关于图像的所有信息就保存到了JPEG对象中，这些信息包括有： output_width：图像的宽度 output_height：图像的高度 out_color_components：# of color components in out_color_space output_components：每一个像素的颜色成分 colormap： the selected colormap, if any actual_number_of_colors： number of entries in colormap Tip：在调用该函数前，图像的各种信息是无法获取的，不过我们也可以在设置完解压缩参数后，调用jpeg_calc_output_dimensions()来使这些参数可用。另外，我们在这一步也需要分配缓存空间，具体可以参见Example-of-IJG-Code中的解压缩部分 解压缩循环操作通过多次调用jpeg_read_scanlines()将解压缩数据读入内存中，返回值是实际读入的scanline的数目。另外，对于灰度JPEG图和彩色JPEG图，其返回的数据格式是不一样的。 这一部分的典型代码为： 123456while(cinfo.output_scanline&lt;cinfo.output_height)&#123; (void)jpeg_read_scanlines(&amp;cinfo,buffer,1); /* 假定put_scanline_someplace需要一个指针和样点数 * do something else */ put_scanline_someplace(buffer[0],row_stride);&#125; 结束解压缩：jpeg_finish_decompress()调用上述函数将会完成解压缩循环，同时释放工作内存。 这一部分的典型代码为： 1jpeg_finish_decompress(&amp;cinfo); 其余注意事项同结束压缩。 释放JPEG解压缩对象这一部分的典型代码为： 1jpeg_destroy_decompress(&amp;cinfo); 中止退出同压缩部分 其他关于ADVANCED FEATURES这一部分建议参阅原文档 参考： 示例：example.c 库说明：libjpeg.txt]]></content>
      <categories>
        <category>data compress</category>
      </categories>
      <tags>
        <tag>JPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Utilities of JPEG]]></title>
    <url>%2F2017%2F02%2F10%2FUtilities-of-Jpeg%2F</url>
    <content type="text"><![CDATA[这篇文章主要对JPEG程序中的cjpeg和djpeg应用程序及其运行选项做学习，其他应用程序jpegtran，rdjpgcom以及wrjpgcom的用法请参阅原文档。如果要将JPEG压缩功能用到自己的程序中，需要参阅其他的几篇说明文档。 一般用法基本命令安装玩IJG JPEG软件包后，我们可以得到可执行程序cjpeg和djpeg，其中 cjpeg：用于将图像文件压缩为JPEG格式，一般用法为： 在类Unix系统中：cjpeg [switches] [imagefile] jpegfile 在所有系统中：cjpeg [switches] -outfile jpegfile imagefile djpeg：用于将JPEG文件解压缩位原始的图像格式，一般用法为： 在类Unix系统中：djpeg [switches] [jpegfile] imagefile 在所有系统中：djpeg [swithes] -outfile imagefile jpegfile 对于swithes，其中的各个选项都是可以缩写的，大部分基础选项甚至可以缩写为一个单词，另外选项大小写不区分。 支持图片文件格式目前支持的图片格式有： PPM (PBMPLUS color format) PGM (PBMPLUS grayscale format) BMP Targa RLE (Utah Raster Toolkit format). RLE is supported only if the URT library is available, which itisn’t on most non-Unix systems. 对于cjpeg命令，其可以自动识别输入文件格式，而对于djpeg，其需要声明产生的文件格式是哪一种。 程序具体运行选项CJPEG的运行选项使用方法对于cjpeg，其基本的命令行选项有： -quality N：压缩比率，实质是通过调节量化表来达到压缩比率的调节，数值为0-100，默认为75。一般来说，quality值设置越高，JPEG文件就会越大，解压缩出的图像与原始图像也越接近。建议设置位50-95之间 -grayscale：从彩色输入文件中产生单色JPEG图，当压缩一个灰度BMP文件时我们需要用这个选项。 -rgb：产生RGB颜色的JPEG文件。我们可以使用这个选项压制RGB颜色空间的输入转化为默认的YCbCr的颜色空间。 -optimize：对熵编码参数进行优化，没有这个选项，将会使用默认的编码参数。该参数通常会使JPEG文件更小一些，但是cjpeg程序会运行更慢一些并且需要更多的内存空间。另外图像解压缩不会受到-optimize的影响 -progressive：Create progressive JPEG file (see below). -scale M/N：Scale the output image by a factor M/N. -targa：Input file is Targa format. 其他的一些选项，如Swithes for advanced users以及Switches for wizards请参阅原始文档。 DJPEG的运行选项使用方法对于djpeg，其基本的命令行选项有： -colors N or -quatize N：将图片减少为最多N种颜色，这将会减少输出文件的颜色数目，因此它能够以colormapped display展示或是以colormapped文件格式存储。 -fast：选择推荐的处理选项用于快速以及低质量的文件输出，默认方式是高质量的文件输出。 -grayscale：强制文件以灰度图输出，在这种模式下，djpeg会运行更快 -rgb：强制文件以RGB文件输出 -scale M/N：Scale the output image by a factor M/N. -bmp：选择以bmp文件格式输出 -gif：选择以gif文件格式输出 其余还有-os2，-pnm，-rle，-Targa文件格式 其他的一些选项，如Swithes for advanced users以及Switches for wizards请参阅原始文档。 一些建议For CJPEG 对于JPEG而言，Gif文件不是理想的输入文件，且现在程序已经不在支持该文件输入 避免对一张图进行重复多次的压缩与解压缩操作，因为图片的损失会累积 运行选项-optimize建议在图片最终版时才用 For DJPEG 我们可以通过使用选项-grayscale或-scale来对图片进行快速预览 -fast选项将会打开所有建议选项进而加快程序运行速度 -dct fast和-nosmooth将会在损失部分质量的前提下加快运行速度 如果机器的浮点运算能力非常强，那么，使用-dct float可能会比-dct fast使程序运行更快 其他程序参阅原文档]]></content>
      <categories>
        <category>data compress</category>
      </categories>
      <tags>
        <tag>JPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPEG实例简析]]></title>
    <url>%2F2017%2F02%2F10%2FJPEG%E5%AE%9E%E4%BE%8B%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[主要介绍如何利用IJG code作为一个子例函数库来读写JPEG图像文件，在阅读该段代码时建议结合文档libjpeg.txt。 source code：example.c reference：USING THE IJG JPEG LIBRARY Part A ：子程序说明- 压缩部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;stdio.h&gt;/* 用于JPEG函数库的头文件，也许还需要 "jerror.h" */#include "jpeglib.h"/* &lt;setjmp.h&gt;用于可选的错误回复机制，这将在该例子的第二部分介绍 */#include &lt;setjmp.h&gt;/**********************************************//* JPEG压缩示例 *//**********************************************//* 这部分例子将会展示如何将数据读入到JPEG压缩器中 *//* * 图像数据格式： * 标准的输入图像数据格式是一个矩形像素阵列，其中每 * 一个像素值有着相同数量的组成（颜色通道），每一 * 个像素行是一个JSAMPLEs的数组（通常是无符号字符型) * 对于颜色数据而言，每一个像素的颜色值在行中必须是 * 相邻的，例如对于24位的RGB数据，其排列为R，G，B， * R，G，B，...除了JSAMPLE，IJG还定义了JSAMPROW和 * JSAMPARRAY，分别表示一行JSAMPLE和一个2D的JSAMPLE数组。 * * 对于本例：图像数据在内存中 * 我们假定数据结构与我们存储在内存中的图形数据的方 * 式相同，因此我们只需要传递指向图像内存的指针即可。 * 特别的，我们假定图像是RGB颜色的，同时其按以下方式 * 描述： */extern JSAMPLE * image_buffer; /* 指向图像数据的指针 */extern int imagine_height; /* 图像的行数 */extern int imagine_width; /* 图像的列数 *//* * JPEG 压缩的示例函数。我们假定目标文件名和压缩的比 * 例系数已经传递进去 */GLOBAL(void)write_JPEG_file(char *filename, int quality) &#123; /* 这个结构体是JPEG库所分配的，它包含了JPEG的压 * 缩参数以及指向指向工作空间的指针，这个结构体可 * 以有多个，进而表示有多个压缩/解压缩要处理，我 * 们任何一个结构体（以及相应所需要处理的数据）为 * "JPEG object" */ struct jpeg_compress_struct cinfo; /* 这个结构体表示JPEG错误处理。它通常是单独声明的 * 因为程序经常需要提供不同的错误处理方式。在这里 * 我们仅仅采用最简单的处理方式，即标准处理方式， * 当压缩失败时，它会在标准错误输出设备中打印错误 * 信息并调用退出函数。 * 注意：这个结构体必须与主要的JPEG参数同时存在， * 从而避免悬空指针问题 */ struct jpeg_error_mgr jerr; /* More stuff */ FILE * outfile; /* 目标文件 */ JSAMPROW row_pointer[1]; /* 指向第s行 JSAMPLES数据的指针 */ int row_stride; /* 图像数据的行数 */ /* Step 1: 分配并初始化JPEG压缩对象 */ /* 我们首先必须建立一个错误处理方式，以防初始化步 * 骤失败。（一般是不可能的，但是如果内存溢出还是 * 出错的） * 绑定标准错误处理结构 */ cinfo.err=jpeg_std_error(&amp;jerr); /* 现在我们可以初始化JPEG压缩对象 */ jpeg_create_compress(&amp;cinfo); /* Step 2: 指定压缩后数据目的地（例如某个文件）*/ /* 注意：Step 2和Step 3次序可任意 */ /* 这里我们使用函数库工的代码将压缩后的数据传递到 * 标准输出流中。同时我们也可以自定义输出方式。 * 非常重要：如果所使用的机器要求顺序写二进制文件 * 我们需要在fopen()中使用选项"b" */ if((outfile = fopen(filename,"wb"))==NULL)&#123; fprintf(stderr,"can't open %s\n",filename); exit(1); &#125; /* 关联JPEG对象与输出文件 */ jpeg_stdio_dest(&amp;cinfo,outfile); /* Step 3: 设置压缩参数 */ /* 首先对输入的图像数据进行描述。 * cinfo中的四个变量必须赋值： */ cinfo.image_width=imagine_width; /* 图像的高度和宽度，以像素点记 */ cinfo.image_height=imagine_height; cinfo.input_components=3; /* 每一个像素点的图像成分,RGB为3，灰度图为1 */ cinfo.in_color_space=JCS_RGB; /* 输入图像的颜色空间，JCS_RGB表示真彩图，灰度图为JCS_GRAYSCALE */ /* 现在使用库函数的子例程序设置默认压缩参数。我们 * 在调用它之前至少需要设置cinfo.in_color_space， * 因为某些默认设置依赖于源的颜色空间。 */ jpeg_set_defaults(&amp;cinfo); /* 现在我们可以按照自己的意愿设置任意一个非默认参数。 * 在这我们只是说明如何设置压缩比（量化表) * * 基线JPEG数值的限制，quality是0~100之间的整数，表示压缩比率 */ jpeg_set_quality(&amp;cinfo, quality, TRUE); / /* Step 4: 开始压缩 */ /* 参数TRUE确保我们将会写入一个完全可以互换的JPEG文 * 件。 */ jpeg_start_compress(&amp;cinfo,TRUE); /* 开始压缩后就不可以修改cinfo对象的参数 */ /* Step 5: while(scan lines remain to be written) * jpeg_write_scanlines(...); */ /* 在这里我们采用库的一个状态变量作为循环参数。为了 * 简单起见，我们一次调用只传递一个scanline，我们也 * 可以一次传递多行。 */ row_stride=imagine_width * 3; /* 在图像内存中JSAMPLEs的每行数据,RGB */ while(cinfo.next_scanline &lt; cinfo.image_height)&#123; /* jpeg_write_scanlines 需要有一个指向scanlines指 * 针的数组。在这里，数组只有一个元素长度，但是我们 * 可以一次传入多条scanline，如果这样更方便的话。*/ row_pointer[0]=&amp;image_buffer[cinfo.next_scanline*row_stride]; (void) jpeg_write_scanlines(&amp;cinfo, row_pointer, 1); &#125; /* Step 6: 完成压缩 */ jpeg_finish_compress(&amp;cinfo); /* 在压缩完毕后，关闭文件 */ fclose(outfile); /* Step 7: 释放JPEG压缩对象 */ /* 这一步十分重要，因为它会释放大量的内存 */ jpeg_destroy_compress(&amp;cinfo); /* 上述函数将会把JPEG压缩对象释放掉，如果 * 需要重复使用该对象，可以使用jpeg_abort() * 来将JPEG对象置为空闲状态 */ &#125;/* * SOME FINE POINTS: * 1、jpeg_write_scanlines的返回值是写入的scanline的行号 * 2、当压缩需要全部的图像内容时，程序会产生一些临时文件， * 我们需要确保当程序终止时这些文件会被删除，详情libjpeg.txt。 * 3、从兼容性考虑，scanlines必须是从上到下的， - 解压缩部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221#include &lt;stdio.h&gt;/* 用于JPEG函数库的头文件，也许还需要 "jerror.h" */#include "jpeglib.h"/* &lt;setjmp.h&gt;用于可选的错误回复机制，这将在该例子的第二部分介绍 */#include &lt;setjmp.h&gt;/**********************************************//* JPEG解压缩示例 *//**********************************************//* 这部分例子将会说明如何从JPEG解压缩器中读入数据， * 与之前相比，这部分内容会更细分一些，具体体现在： * (a) 如何修改JPEG库中标准错误报告的行为； * (b) 如何使用函数库的内存管理分配工作区间； * * 为了使这部分的程序与前面的有所不同，我们假定不将所 * 有的图像数据都传送到内存中，而是将其一行一行的发送 * 到其他地方。我们需要一个one-scanline-high的JSAMPLE * 类型的数组作为一个工作区缓存，并且将利用JPEG的内存 * 管理器为我们分配空间。这种方法实际上是相当有效的， * 因为我们不必特地去释放缓存空间：它会自动释放当JPEG * 对象被清理后。 *//* * Error Handling * JPEG函数库的标准错误处理（jerror.c）被分为几个不同 * 的方法，它们可以单独被重载。这将使我们可以调整相应的 * 行为而不用重复一大段代码。 * * 这里我们将展示如何重载"error_exit"方法，因而当有关键 * 错误产生时，程序控制将会返回到函数的调用着，而不是像 * 标准error_exit那样，调用exit()。 * * 我们使用C的 setjmp/longjmp 工具来返回控制。这就意味着 * 调用了JPEG库的子例程序必须首先执行一次setjmp()调用进而 * 建立返回点。我们想让error_exit替换为调用一次longjmp(), * 但是我们需要使setjmp缓存对error_exit子例程序是可获取的。 * 因此，我们制定了标准JPEG错误处理对象的私有扩展。（在C++ * 中，这个称之为子类） * * From：http://www.cnblogs.com/hzhida/archive/2012/05/30/2524989.html * 在使用默认错误处理结构jpeg_error_mgr的情况下，程序在遇到错误后将调用exit直接退出程序，用户如果不 * 希望使用这种直接退出的方式处理错误的话就需要自定义错误处理结构。依照example.c中的例子，IJG推荐使 * 用C语言的setjmp和longjmp机制来重写错误处理结构。需要头文件setjmp.h * * 扩展的错误处理结构体如下： * 首先，需要定义一个包含标准错误处理结构类型变量的自定义结构。 */struct my_error_mgr&#123; struct jpeg_error_mgr pub; /* “公共”部分 */ jmp_buf setjmp_buffer; /* 用于返回给调用的对象 */&#125;;typedef struct my_error_mgr * my_error_ptr;/* 这是将要替代标准error_exit方法的子例程序 * 在出现错误时程序将跳转到本函数中，而本函 * 数将跳转到setjmp设定的程序位置。*/METHODDEF(void) my_error_exit(j_common_ptr cinfo)&#123; /* cinfo-&gt;err实际指向一个my_error_mgr结构体 */ my_error_ptr myerr=(my_error_ptr)cinfo-&gt;err; /* 总是显示信息 */ (*cinfo-&gt;err-&gt;output_message)(cinfo); /* 返回控制到setjmp point */ longjmp(myerr-&gt;setjmp_buffer,1);&#125;/* 示例子程序用于JPEG解压缩。我们假定源文件名字已经传递进去， * 并且成功返回1，出错返回0 */GLOBAL(int)read_JPEG_file(char * filename)&#123; /* 这个结构体包含了JPEG解压缩的参数以及指向工作空间的指针 */ struct jpeg_decompress_struct cinfo; /* 我们将使用我们扩展后的JPEG错误处理方法。注意到这个结构 * 体必须与主要的JPEG参数同时存在，从而避免悬空指针问题. */ struct my_error_mgr jerr; /* More stuff */ FILE *infile; /* JPEG源文件 */ JSAMPARRAY buffer; /* 输出的行缓存内容 */ int row_stride; /* 在输出缓存中的物理行宽 */ /* 在这个例子中，我们在做任何其他操作钱将先打开输入文件， * 进而下面的setjmp()的error recovery可以假定文件是打开 * 的。 * 非常重要：如果所使用的机器要求顺序写二进制文件我们需要 * 在fopen()中使用选项"b" */ if((infile=fopen(filename,"rb"))==NULL)&#123; fprintf(stderr,"can't open %s\n",filename); return 0; &#125; /* Step 1: 分配并初始化JPEG解压缩对象 */ /* 我们建立了一般的JPEG错误子例程序，然后重载了error_exit */ /* 错误处理修改1 */ cinfo.err=jpeg_std_error(&amp;jerr.pub); jerr.pub.error_exit=my_error_exit; /* 为了my_error_exit使用建立setjmp的返回上下文 */ if(setjmp(jerr.setjmp_buffer))&#123; /* 如果程序运行到了这，说明JPEG代码中出现了一个错误， * 即调用my_error_exit，然后程序将再次跳转于此，同时 * setjmp将返回在my_error_exit中由longjmp第二个参数 * 设定的值1 * 我们需要释放JPEG对象，关闭输入文件，并且返回 */ jpeg_destroy_decompress(&amp;cinfo); fclose(infile); return 0; &#125; /* 现在我们可以初始化JPEG解压缩对象 */ jpeg_create_decompress(&amp;cinfo); /* Step 2: 指定数据源（例如一个文件） */ jpeg_stdio_src(&amp;cinfo, infile); /* Step 3:使用jpeg_read_header读入文件参数 */ (void)jpeg_read_header(&amp;cinfo,TRUE); /* IJG将图像的缺省信息填充到cinfo结构中以便程序使用 * *我们可以忽略jpeg_read_header函数的返回值，因为 * (a)对于标准输入输出数据源，暂停是不可能的，并且 * (b)我们传递TRUE进而拒绝只有表格的JPEG文件作为 * 一个错误。 * 更多信息可以参见libjpeg.txt。 */ /* Step 4: 设置用于解压缩的参数 */ /* 比如可以设定解出来的图像的大小，也就是与原图的比 * 例。使用scale_num和scale_denom两个参数，解出来的 * 图像大小就是scale_num/scale_denom，但是IJG当前仅 * 支持1/1, 1/2, 1/4,和1/8这几种缩小比例。 * * 若要获得1/2原图的图像，我们需要如下设置 */ cinfo.scale_num=1; cinfo.scale_denom=2; /* 也可以设定图像的彩色空间，可以把一个原本彩色的图像 * 由真彩色JCS_RGB变为灰度JCS_GRAYSCALE */ cinfo.out_color_space=JCS_GRAYSCALE; /* 如果我们使用默认参数，那么在这我们不必做任何事。 */ /* Step 5: 开始解压缩 */ (void)jpeg_start_decompress(&amp;cinfo); /* 我们可以忽略函数返回值。 * * 在完成解压缩操作后，IJG就会将解压后的图像信息填充 * 至cinfo结构中。比如，输出图像宽度cinfo.output_width， * 输出图像高度cinfo.output_height，每个像素中的颜色通 * 道数cinfo.output_components（比如灰度为1，全彩色为3）等 * * 在这里我们可能需要做一些自己的设置在读入数据之前，在 * jpeg_start_compress()之后，我们得到了正确的被放大后 * 的输出图像维度，以及输出的颜色映射表（如果我们要颜色 * 量化的话）。 * 在这个例子中，我们需要创建一个正确大小的输出文件缓存 */ /* 计算每行需要的空间大小 */ row_stride=cinfo.output_width*cinfo.output_components; /* Make a one-row-high sample array that will go away when done with image */ /* 为缓冲区分配空间，这里使用了IJG的内存管理器来完成分配。 * * JPOOL_IMAGE表示分配的内存空间将在调用jpeg_finish_compress， * jpeg_finish_decompress，jpeg_abort后被释放，而如果此参数改 * 为JPOOL_PERMANENT则表示内存将一直到JPEG对象被销毁时才被释放。 * 最后一个参数是要分配多少行数据。此处只分配了一行。 */ buffer=(*cinfo.mem-&gt;alloc_sarray)((j_commom_ptr)&amp;cinfo, JPOOL_IMAGE,row_stride,1); /* Step 6:while (scan lines remain to be read) * jpeg_read_scanlines(...); */ /* 在这里我们采用库的一个状态变量作为循环参数。 */ while(cinfo.output_scanline&lt;cinfo.output_height)&#123; /* jpeg_read_scanlines 需要有一个指向scanlines指 * 针的数组。在这里，数组只有一个元素长度，但是我们 * 可以一次传入多条scanline，如果这样更方便的话。 * output_scanline表示当前已经读取的行数，如此即可 * 依次读出图像的所有数据，并填充到缓冲区中，参数1表 * 示的是每次读取的行数。 */ (void)jpeg_read_scanlines(&amp;cinfo,buffer,1); /* 假定put_scanline_someplace需要一个指针和样点数 */ put_scanline_someplace(buffer[0],row_stride); &#125; /* Step 7: 完成解压缩 */ (void)jpeg_finish_decompress(&amp;cinfo); /* 我们可以忽略返回值 */ /* Step 8: 释放JPEG解压缩对象 */ /* 这一步十分重要，因为它会释放大量的内存 */ jpeg_destroy_decompress(&amp;cinfo); /* 在完成解压缩后，我们可以关闭输入文件。 * 在这里我们推迟关闭文件直到没有更多的JPEG错误出现， * 以便简化上述的setjmp错误逻辑。 */ fclose(infile); /* 在这时，如果我们想检查是否有任何损坏数据警告产生， * 我们可以通过测试jerr.pub.num_warning 是否位零来 * 确认 。 */ return 1;&#125;/* * SOME FINE POINTS: * 1、在上述代码中，我们可以忽略jpeg_read_scanlines的返回值； * 2、我们在jpeg_start_compress()后做了一点弊，直接调用了alloc_array(),一般我们应该先确认 * 输出图像的数据大小，否则会发生内存溢出错误； * 3、scanlines的顺序是从上到下的； * 4、和压缩操作一样，解压缩的一些操作也会产生临时文件，当程序中止时我们需要清除这些临时文件。 Part B：必备数据类型及函数说明数据类型 JSAMPLE：一种自定义数据类型，通常是”unsigned char”，除非修改了头文件”jmorecfg.h”。详情请参见头文件jmorecfg.h。 JSAMPROW：同上，表示一行JSAMPLE类型的数组 JSAMPARRAY：同上，表示一个2DJSAMPLE类型的数组 struct jpeg_compress_struct：jpeg压缩对象结构体 struct jpeg_decompress_struct：jpeg解压缩对象结构体 struct jpeg_error_mgr：jpeg错误处理结构体 ​ 函数定义 jpeg_std_error(&amp;jerr)：建立错误处理方式 jpeg_create_compress(&amp;cinfo)：初始化JPEG压缩对象 jpeg_stdio_dest(&amp;cinfo, outfile)：关联jpeg对象与输出文件 jpeg_set_default(&amp;cinfo)：设置默认压缩参数 jpeg_set_quality(&amp;cinfo, quality, TRUE)：设置图片的压缩率，数值越大，压缩越小 jpeg_start_compress(&amp;cinfo, TRUE)：开始压缩 jpeg_write_scanlines(&amp;cinfo, row_pointer, 1)：将row_pointer指向的1行scanline写入文件中 jpeg_finish_compress(&amp;cinfo)：完成压缩 jpeg_destroy_compress(&amp;cinfo)：释放JPEG压缩对象 setjmp：具体参阅原文档 longjmp：具体参阅原文档 jpeg_create_decompress(&amp;cinfo)：初始化JPEG解压缩对象 jpeg_stdio_src(&amp;cinfo, infile)：指定数据源 jpeg_read_header(&amp;cinfo, TRUE)：读入文件的头部信息 jpeg_start_decompress(&amp;cinfo)：开始解压缩 jpeg_read_scanlines(&amp;cinfo, buffer, 1)：读入数据并将其存储到缓存区中，1表示每次读出的行数 put_scanline_someplace：自定义函数 jpeg_finish_decompress(&amp;cinfo)：完成解压缩 jpeg_destroy_decompress(&amp;cinfo)：释放JPEG解压缩对象 更多详细内容，请参考原文档： source code：example.c reference：USING THE IJG JPEG LIBRARY]]></content>
      <categories>
        <category>data compress</category>
      </categories>
      <tags>
        <tag>JPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPEG配置安装官方指南]]></title>
    <url>%2F2017%2F02%2F10%2FJPEG%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E5%AE%98%E6%96%B9%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[这应该是libjpeg函数库中安装指导文件install.txt的中文简译版本，只给出了一个大致流程以及一些注意事项，更多详细内容可以参看原文件。 JPEG软件包安装软件包配置使用命令./configure，生成文件jconfig.h以及Makefile 一些配置选项： configure将会编译静态和动态函数库，若只想编译其中之一， ./configure --diasble-shared：只编译静态库 ./configure --diasble-static：只编译动态库 configure将会默认使用gcc（GUN C compiler）作为编译器，如想用cc作为编译器，则需要 ./configure CC=&#39;cc&#39; 默认的CFLAGS设置对于非gcc类编译器位”-g”，对于gcc编译器为”-g -O2”，我们可以改写为 ./configure CFLAGS=&#39;-O2&#39;：-O2表示采用的优化级别位2 指定特定的安装位置 ./configure --prefix=PATH ​ 软件包编译使用命令make 软件包测试使用命令make test 我们也可以通过手动运行程序djpeg和cjpeg来得到输出文件testimg*，然后利用二进制比较文件将我们获得的文件与软件包中已有的文件比较，若文件完全相同，说明程序编译没有问题。 若程序报错，则去install.txt中的本部分内容（TESTING THE SOFTWARE）下查找相关解决方法。 软件包安装使用命令make install 在这里我们建议首先执行命令make -n install查看配置文件中软件的安装位置，必要时需要修稿Makefile中软件的安装位置。 如果我们想将IJG Library库用于编译其他程序，我们需要将以下四个头文件放入我们的项目文件夹中：jpeglib.h,jerror.h,jconfig.h,jmorecfg.h，并且我们也需要将libjpeg.a放在与library files一起的地方（翻译太蹩脚： put the library file libjpeg.a wherever library files go.）当然如果我们按照上述步骤走了下来，我们实际已经安装了所需的library，若只想安装library，我们可以运行make install-lib。 Optional Stuff9-12位大像素值支持9-12位大像素值，对于每一个颜色通道来说，就是每一个颜色通道的数值可以扩展到2的9直至12次方。为了能够实现这种操作，我们需要按照如下操作： 在jmorecfg.h头文件中，定义BITS_IN_JSAMPLE的值位9,10,11或12，而不是8 在jconfig.h头文件中，注释掉BMP_SUPPORTED，RLE_SUPPORTED，和TARGA_SUPPORTED，因为这些格式的代码不会处理超过8位的数据，甚至不能通过编译。（PPM和GIF的代码在超过8位的情况下仍能正常运行） 编译，不要运行make test，因为相应的源文件是8位的 注意：标准的Huffman表只支持8位的数据，如果我们的数据超过8位，cjpeg将会默认采用算术编码。而Huffman解码器将会使用熵优化来计算出高数据位的可用解码表，否则，我们就得提供不同的默认Huffman编码表。另外有一点要说明的是目前大像素值压缩计算在16-bit-int的机器上是不支持的，简言之，就是不支持16位的机器。 优化措施建议：在做出优化改动前，首先要保证以上基本安装正确且能通过自测。以下的各种优化改进后都需要进行自测以确保未对程序的其他部分造成破坏。（具体优化方法参阅原文） DCT乘法运算优化：修改jdct.h中的MULTIPLYxxx宏定义（文件中已给出） DCT浮点数计算优化：若处理器计算浮点数能力较强，则可能DCT浮点计算要快鱼DCT整数计算，因此我们可以将DCT的浮点数计算作为我们的默认计算方式，修改方式：增加#define JDCT_DEFAULT JDCT_FLOAT到jconfig.h 头文件中 内联函数：若编译器支持内联函数，确保jmorecfg.h中的INLINE宏已定义 参考资料：install.txt]]></content>
      <categories>
        <category>data compress</category>
      </categories>
      <tags>
        <tag>JPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++预处理指令]]></title>
    <url>%2F2017%2F02%2F09%2FC-C-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近在看IJG JPEG函数库的一些代码时发现开发者在程序中用了许多的预处理命令，加之以前就遇到过好多次但是一直没有花时间去学习，就趁这次机会好好的学习一下。 本文主要记录一些常用的C/C++预处理指令并对其用法进行简要介绍，参考来源已附文末。 常见的预处理命令大致如下： #空指令：无任何效果 #include：包含一个源代码文件 #define：定义宏 #undef：取消已定义的宏 #if：如果给定条件为真，则编译下面代码 #ifdef：如果宏已经定义，则编译下面代码 #ifndef：如果宏没有定义，则编译下面代码 #elif：如果前面给定的#if条件不为真，当前条件为真，则编译下面代码 #endif：结束一个#if...#else条件编译块 #error：停止编译并显示错误信息 什么是预处理指令预处理指令：以#号开头的代码行。 一般规则是： #号必须是该行除了任何空白字符外的第一个字符； #后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符; 整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。 需要注意的是：预处理指令是在编译器进行编译之前进行的操作。预处理过程扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。 常见的预处理指令#include作用：包含一个源代码文件（也就是我们经常说的头文件）。一般来说，头文件主要有两大类： 标准库中的头文件：使用尖括号括起来，使用时从标准库中寻找 自定义的头文件：使用双引号括起来，使用时从当前源代码文件中寻找，若找不到，再从标准库中寻找 #define作用：定义一个宏（macro）。其全称应该位宏指令（macroinstruction），简单来说就是把较长的指令序列用某种规则对应到较短的指令序列的规则或模式。在office中的宏实质是一系列的批处理命令，而在我们目前所研究的C语法中，其只是简单的文本搜索和替换，不做计算也不做表达式求解，因而在C++中，一般建议使用const来定义常量进而替换宏，因为const会有常量的数据类型。宏一般有两类： 不带参数： 12#define MAX 1000int a=MAX; 带参数： 1234#define SQR(x) ((x)*(x)) //参数括号建议加上#ifdef SQR //只需要宏名，不用带参数，带入参数将报错 b=SQR(a+3);#endif 带参数宏中#的使用： 123456789101112131415#define STR(s) #s#define CONS(a,b) (int)(a##e##b)#ifdef STR printf(STR(VCK)); //将参数转化为一个字符串#endif#ifdef CONS printf(CONS(1,2)); //将宏参数连在一起，也就是aeb，代入参数1e2，表示100#endif/* #的作用 * 一个#表示将参数转为一个字符串； * 两个#表示将参数连接在一起； */ 空宏定义（e.g.：#define DEBUG） 作用：只有一个参数的宏称为空宏定义，其不对代码产生任何影响。主要是为了方便代码阅读（如__IN__和__OUT__宏表示参数是输入还是输出）和作为标记（UNICODE和DEBUG）进而切换配置，自己写程序时可以多加留意。常与其他一些预处理命令连用来进行代码调试和维护。 123456789101112#include &lt;stdio.h&gt;#define D(x)int main()&#123; D(printf("null macro")); //不进行任何操作，等同于代码注释 return 0;&#125;/* #define D(x) * 等同于 * #define D(x) do&#123;&#125;while(0) 执行一次便退出，并且执行内容为空 */ 预定义宏 作用：在C中预定义了一些宏，称为预定义宏，主要用来提供当前编译的信息。主要由以下几种： __LINE__：被编译的文件的行数，整型常量 __FILE__：被编译的文件的名字，字符串 __DATE__：编译的日期（格式为M D Y形式的字符串） __TIME__：编译的时间（格式为h:m:s形式的字符串) __STDC__：如果编译器接受标准C，那么值为整型常量1 __func__：当前所在函数名，在C++中为__FUNCTION__，在VC中不支持该宏，但在g++中可以使用 1234567891011121314151617181920212223/* 一般用法 */#include&lt;iostream&gt; using namespace std; #ifndef __func__#define __func__ (__FUNCTION__)#endif void func()&#123; cout&lt;&lt;"func name is:"&lt;&lt;__func__&lt;&lt;endl; cout&lt;&lt;"func name is:"&lt;&lt;__FUNCTION__&lt;&lt;endl; //在C中将会报错，但在C++中不会 &#125; int main()&#123; cout&lt;&lt;"date is :"&lt;&lt;__DATE__&lt;&lt;endl; cout&lt;&lt;"time is :"&lt;&lt;__TIME__&lt;&lt;endl; cout&lt;&lt;"file is :"&lt;&lt;__FILE__&lt;&lt;endl; cout&lt;&lt;"line is :"&lt;&lt;__LINE__&lt;&lt;endl; func();&#125; #ifdef, #ifndef, #endif作用：条件编译指令，将决定程序中哪些代码被编译，而哪些代码不被编译 define - ifdef - endif 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define DEBUGint main(void)&#123; int i = 0; char c; while(1) &#123; i++; c = getchar(); if('\n' != c) &#123; getchar(); &#125; if('q' == c || 'Q' == c) &#123;#ifdef DEBUG //判断DEBUG是否被定义了 printf("We get:%c,about to exit.\n",c);#endif break; &#125; else &#123; printf("i = %d",i);#ifdef DEBUG printf(",we get:%c",c);#endif printf("\n"); &#125; &#125; printf("Hello World!\n"); return 0;&#125;/*#endif用于终止#ifdef预处理指令。*/ ifdef - ifndef 12345678910111213#include &lt;stdio.h&gt;#define DEBUGmain()&#123;#ifdef DEBUG printf("yes ");#endif#ifndef DEBUG printf("no ");#endif&#125;//#ifdefined等价于#ifdef;//#if!defined等价于#ifndef if - else - endif 在预处理阶段就智能屏蔽掉相应的语句，在实际编译时屏蔽掉的语句不再进行编译。 if - elseif - else - endif 适用于多个条件，进而将需要编译的部分代码在编译前就进行确认。 实战借鉴利用宏来调试代码在不删除代码的前提下修改代码，可以利用预处理命令来实现。学会利用宏来注释代码 1234567891011121314151617#if 0///&lt; 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)#else///&lt; 新的代码(或函数)#endif #ifndef JOE_DEBUG///&lt; 新的代码(或函数)#else///&lt; 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)#endif #ifdef Q_DEBUG///&lt; 新的代码(或函数)#else///&lt; 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)#endif 跨平台编程根据不同平台本省自带的有别于其他平台的系统宏，我们可以实现代码在各个平台之间的无缝移植。 1234567891011#ifdef OS_Win#include &lt;windows.h&gt;#endif #ifdef OS_Mac#include &lt;mac.h&gt;#endif #ifdef OS_Linux#include &lt;linux.h&gt;#endif 其他还有另外的一些系统自定义的预处理命令，如#line，#error等，对于#error，我们可以利用其来显示错误信息， 1234/* 如果JOE宏没有定义,那么编译就此结束, 编译器就会显示红色的错误 */#ifndef JOE#error "JOE is not exits"#endif 参考来源： C/C++预处理指令#define,#ifdef,#ifndef,#endif… 预处理命令 C语言中的宏定义]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,strangers~]]></title>
    <url>%2F2017%2F02%2F09%2FHello-strangers%2F</url>
    <content type="text"><![CDATA[How do you do？ 这是我的个人Blog，初期刚建，欢迎交流探讨～ 博客内容主要是个人的学习总结以及一些感悟，如果你和我一样，欢迎交友～ 现在是南七技校苦逼研究生一名，前途渺茫未知，但却一直努力着！ I don’t know where to go, but I have been on the road!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>你好~</tag>
      </tags>
  </entry>
</search>